msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: documentation\n"
"title: 15 Minutes Tutorial\n"
"part: Getting Started\n"
"---"
msgstr ""

msgid "# {{page.title}} {#domain-model-walkthrough}"
msgstr ""

msgid ""
"In this tutorial we will implement a small domain-specific language to model e"
"ntities and properties similar to what you may know from Rails, Grails or Spri"
"ng Roo. The syntax is very suggestive:"
msgstr ""

msgid ""
"```domainexample\n"
"datatype String"
msgstr ""

msgid ""
"entity Blog {\n"
"    title: String\n"
"    many posts: Post\n"
"}"
msgstr ""

msgid ""
"entity HasAuthor {\n"
"    author: String\n"
"}"
msgstr ""

msgid ""
"entity Post extends HasAuthor {\n"
"    title: String\n"
"    content: String\n"
"    many comments: Comment\n"
"}"
msgstr ""

msgid ""
"entity Comment extends HasAuthor {\n"
"    content: String\n"
"}\n"
"```"
msgstr ""

msgid ""
"After you have installed Xtext on your machine, start Eclipse and set up a fre"
"sh workspace."
msgstr ""

msgid "## Create A New Xtext Project"
msgstr ""

msgid ""
"In order to get started we first need to create some Eclipse projects. Use the"
" Eclipse wizard to do so:"
msgstr ""

msgid "*File &rarr; New &rarr; Project... &rarr; Xtext &rarr; Xtext project*"
msgstr ""

msgid "Choose a meaningful project name, language name and file extension, e.g."
msgstr ""

msgid ""
"|:---|:---|\n"
"|**Project name:**|org.example.domainmodel|\n"
"|**Language name:**|org.example.domainmodel.Domainmodel|\n"
"|**DSL-File extensions:**|dmodel|"
msgstr ""

msgid "Click on *Finish* to create the projects."
msgstr ""

msgid "![](images/30min_wizard.png)"
msgstr ""

msgid ""
"After you have successfully finished the wizard, you will find five new projec"
"ts in your workspace."
msgstr ""

msgid ""
"|:---|:---|\n"
"|org.example.domainmodel|The grammar definition and all language-specific comp"
"onents (parser, lexer, linker, validation, etc.)|\n"
"|org.example.domainmodel.ide|Platform-independent IDE functionality (e.g. serv"
"ices for content assist)|\n"
"|org.example.domainmodel.tests|Unit tests for the language|\n"
"|org.example.domainmodel.ui|The Eclipse editor and other workbench related fun"
"ctionality|\n"
"|org.example.domainmodel.ui.tests|UI tests for the Eclipse editor|"
msgstr ""

msgid "![](images/30min_initialprojectlayout.png)"
msgstr ""

msgid "## Write The Grammar"
msgstr ""

msgid ""
"The wizard will automatically open the grammar file *Domainmodel.xtext* in the"
" editor. As you can see it already contains a simple *Hello World* grammar:"
msgstr ""

msgid ""
"```xtext\n"
"grammar org.example.domainmodel.Domainmodel with\n"
"                                      org.eclipse.xtext.common.Terminals"
msgstr ""

msgid "generate domainmodel \"http://www.example.org/domainmodel/Domainmodel\""
msgstr ""

msgid ""
"Model:\n"
"    greetings+=Greeting*;"
msgstr ""

msgid ""
"Greeting:\n"
"    'Hello' name=ID '!';\n"
"```"
msgstr ""

msgid ""
"Let's now just replace that grammar definition with the one for our entities l"
"anguage:"
msgstr ""

msgid ""
"Domainmodel:\n"
"    (elements+=Type)*;"
msgstr ""

msgid ""
"Type:\n"
"    DataType | Entity;"
msgstr ""

msgid ""
"DataType:\n"
"    'datatype' name=ID;"
msgstr ""

msgid ""
"Entity:\n"
"    'entity' name=ID ('extends' superType=[Entity])? '{'\n"
"        (features+=Feature)*\n"
"    '}';"
msgstr ""

msgid ""
"Feature:\n"
"    (many?='many')? name=ID ':' type=[Type];\n"
"```"
msgstr ""

msgid "Let's have a more detailed look at what the different grammar rules mean:"
msgstr ""

msgid "1.  The first rule in a grammar is always used as the start rule."
msgstr ""

msgid ""
"    ```xtext\n"
"    Domainmodel:\n"
"        (elements+=Type)*;\n"
"    ```"
msgstr ""

msgid ""
"    It says that a *Domainmodel* contains an arbitrary number (`*`) of *Type*s"
" which are added (`+=`) to a feature called `elements`.\n"
"1.  The rule *Type* delegates to either the rule *DataType* or (`|`) the rule "
"*Entity*."
msgstr ""

msgid ""
"    ```xtext\n"
"    Type:\n"
"        DataType | Entity;\n"
"    ```"
msgstr ""

msgid ""
"1.  The rule *DataType* starts with a keyword `'datatype'`, followed by an ide"
"ntifier which is parsed by a rule called *ID*. The rule *ID* is defined in the"
" super grammar *org.eclipse.xtext.common.Terminals* and parses a single word, "
"a.k.a identifier. You can navigate to the declaration by using *F3* on the rul"
"e call. The value returned by the call to *ID* is assigned (`=`) to the featur"
"e `name`."
msgstr ""

msgid ""
"    ```xtext\n"
"    DataType:\n"
"        'datatype' name=ID;\n"
"    ```"
msgstr ""

msgid ""
"1.  The rule *Entity* again starts with the definition of a keyword followed b"
"y a name."
msgstr ""

msgid ""
"    ```xtext\n"
"    Entity :\n"
"        'entity' name=ID ('extends' superType=[Entity])? '{'\n"
"            (features+=Feature)*\n"
"        '}';\n"
"    ```"
msgstr ""

msgid ""
"    Next up there is the `extends` clause which is parenthesized and optional "
"(`?`). Since the feature named `superType` is a cross reference (note the squa"
"re brackets), the parser rule *Entity* is not called here, but only a single i"
"dentifier (the *ID*-rule) is parsed. The actual *Entity* to assign to the `sup"
"erType` reference is resolved during the linking phase. Finally between curly "
"braces there can be any number of *Features*, which invokes the next rule.\n"
"1.  Last but not least, the rule *Feature* is defined as follows:"
msgstr ""

msgid ""
"    ```xtext\n"
"    Feature:\n"
"        (many?='many')? name=ID ':' type=[Type];\n"
"    ```"
msgstr ""

msgid ""
"    The keyword `many` shall be used to model a multi-valued feature in this D"
"SL. The assignment operator (`?=`) implies that the feature `many` is of type "
"*boolean*. You are already familiar with the other syntax elements in this par"
"ser rule."
msgstr ""

msgid ""
"This entities grammar already uses the most important concepts of Xtext's gram"
"mar language. You have learned that keywords are written as string literals an"
"d a simple assignment uses a plain equal sign (`=`), whereas a multi-value ass"
"ignment uses a plus-equals (`+=`). We have also seen the boolean assignment op"
"erator (`?=`). Furthermore the example contains syntax elements with different"
" cardinalities (`?` = optional, `*` = any number, `+` = at least once) and dem"
"onstrates how cross-references can be declared. Please consult the [Grammar La"
"nguage Reference](301_grammarlanguage.html) for more details. Let's now have a"
" look what you can do with such a language description."
msgstr ""

msgid "## Generate Language Artifacts"
msgstr ""

msgid ""
"Now that we have the grammar in place we need to execute the code generator th"
"at will derive the various language components. To do so, right-click into the"
" grammar editor and select"
msgstr ""

msgid "*Run As &rarr; Generate Xtext Artifacts*."
msgstr ""

msgid ""
"This action generates the parser and text editor and some additional infrastru"
"cture code. You will see its logging messages in the Console View."
msgstr ""

msgid "![](images/30min_rungenerator.png)"
msgstr ""

msgid "## Run the Generated Eclipse Plug-in {#run-generated-plugin}"
msgstr ""

msgid ""
"We are now able to test the Eclipse IDE integration. If you right-click the pr"
"oject `org.example.domainmodel` in the Package Explorer and select *Run As &ra"
"rr; Eclipse Application*, a new run configuration is created and launched that"
" starts a second instance of Eclipse including your new language plug-ins. In "
"the new instance, create a new project of your choice, e.g. *File &rarr; New &"
"rarr; Project... &rarr; Java Project* and therein a new file with the file ext"
"ension you chose in the beginning (*\\*.dmodel*). This will open the generated "
"entity editor. Try it and discover the default functionality for code completi"
"on, syntax highlighting, syntactic validation, linking errors, formatting, (qu"
"ick) outline view, hyperlinking, find references, folding, rename refactoring "
"etc."
msgstr ""

msgid "![](images/30min_editor.png)"
msgstr ""

msgid "## Second Iteration: Adding Packages and Imports {#add-imports}"
msgstr ""

msgid ""
"After you have created your first DSL and had a look at the editor, the langua"
"ge should be refined and incrementally enhanced. The domainmodel language shou"
"ld support the notion of *Packages* in order to avoid name clashes and to bett"
"er fit with the target environment Java. A *Package* may contain *Types* and o"
"ther packages. In order to allow for names in references, we will also add a w"
"ay to declare imports."
msgstr ""

msgid ""
"In the end we want to be able to split the previously used model into distinct"
" files:"
msgstr ""

msgid ""
"```domainexample\n"
"// datatypes.dmodel"
msgstr ""

msgid ""
"datatype String\n"
"```"
msgstr ""

msgid ""
"```domainexample\n"
"// commons.dmodel"
msgstr ""

msgid "package my.company.common {"
msgstr ""

msgid ""
"    entity HasAuthor {\n"
"        author: String\n"
"    }\n"
"}\n"
"```"
msgstr ""

msgid ""
"```domainexample\n"
"// blogs.dmodel"
msgstr ""

msgid "package my.company.blog {"
msgstr ""

msgid "    import my.company.common.*"
msgstr ""

msgid ""
"    entity Blog {\n"
"        title: String\n"
"        many posts: Post\n"
"    }"
msgstr ""

msgid ""
"    entity Post extends my.company.common.HasAuthor {\n"
"        title: String\n"
"        content: String\n"
"        many comments: Comment\n"
"    }"
msgstr ""

msgid ""
"    entity Comment extends HasAuthor {\n"
"        content: String\n"
"    }\n"
"}\n"
"```"
msgstr ""

msgid "Let's start enhancing the grammar."
msgstr ""

msgid ""
"1.  Since a *Domainmodel* no longer contains types but also packages, the entr"
"y rule has to be modified. Furthermore, a common super type for *PackageDeclar"
"ations* and *Types* should be introduced: the *AbstractElement*."
msgstr ""

msgid ""
"    ```xtext\n"
"    Domainmodel:\n"
"        (elements+=AbstractElement)*;"
msgstr ""

msgid ""
"    AbstractElement:\n"
"        PackageDeclaration | Type;\n"
"    ```"
msgstr ""

msgid ""
"1.  A `PackageDeclaration` in turn looks pretty much as expected. It contains "
"a number of *Imports* and *AbstractElements*. Since *Imports* should be allowe"
"d for the root-Domainmodel, too, we add them as an alternative to the rule `Ab"
"stractElement`."
msgstr ""

msgid ""
"    ```xtext\n"
"    PackageDeclaration:\n"
"        'package' name=QualifiedName '{'\n"
"            (elements+=AbstractElement)*\n"
"        '}';"
msgstr ""

msgid ""
"    AbstractElement:\n"
"        PackageDeclaration | Type | Import;"
msgstr ""

msgid ""
"    QualifiedName:\n"
"        ID ('.' ID)*;\n"
"    ```"
msgstr ""

msgid ""
"    The `QualifiedName` is a little special. It does not contain any assignmen"
"ts. Therefore it serves as a data type rule that returns a String. Hence the f"
"eature `name` of a *Package* is still of type [String]({{site.javadoc.java}}/j"
"ava/lang/String.html).\n"
"1.  Imports can be defined in a very convenient way with Xtext. If you use the"
" name `importedNamespace` in a parser rule, the framework will treat the value"
" as an import. It even supports wildcards and handles them as expected:"
msgstr ""

msgid ""
"    ```xtext\n"
"    Import:\n"
"        'import' importedNamespace=QualifiedNameWithWildcard;"
msgstr ""

msgid ""
"    QualifiedNameWithWildcard:\n"
"        QualifiedName '.*'?;\n"
"    ```"
msgstr ""

msgid ""
"    Similar to the rule `QualifiedName`, `QualifiedNameWithWildcard` returns a"
" plain string.\n"
"1.  The last step is to allow fully qualified names in cross-references, too. "
"Otherwise one could not refer to an entity without adding an import statement."
msgstr ""

msgid ""
"    ```xtext\n"
"    Entity:\n"
"        'entity' name=ID ('extends' superType=[Entity|QualifiedName])? '{'\n"
"            (features+=Feature)*\n"
"        '}';"
msgstr ""

msgid ""
"    Feature:\n"
"        (many?='many')? name=ID ':' type=[Type|QualifiedName];\n"
"    ```"
msgstr ""

msgid ""
"    Please note that the bar (`|`) is not an alternative in the context of a c"
"ross-reference, but used to specify the syntax of the parsed string."
msgstr ""

msgid "That's all for the grammar. It should now read as"
msgstr ""

msgid ""
"Domainmodel:\n"
"    (elements+=AbstractElement)*;"
msgstr ""

msgid ""
"PackageDeclaration:\n"
"    'package' name=QualifiedName '{'\n"
"        (elements+=AbstractElement)*\n"
"    '}';"
msgstr ""

msgid ""
"AbstractElement:\n"
"    PackageDeclaration | Type | Import;"
msgstr ""

msgid ""
"QualifiedName:\n"
"    ID ('.' ID)*;"
msgstr ""

msgid ""
"Import:\n"
"    'import' importedNamespace=QualifiedNameWithWildcard;"
msgstr ""

msgid ""
"QualifiedNameWithWildcard:\n"
"    QualifiedName '.*'?;"
msgstr ""

msgid ""
"Entity:\n"
"    'entity' name=ID ('extends' superType=[Entity|QualifiedName])? '{'\n"
"        (features+=Feature)*\n"
"    '}';"
msgstr ""

msgid ""
"Feature:\n"
"    (many?='many')? name=ID ':' type=[Type|QualifiedName];\n"
"```"
msgstr ""

msgid ""
"You should regenerate the language infrastructure as described in the previous"
" section, and give the editor another try. You can even split up your model in"
"to smaller parts and have cross-references across file boundaries."
msgstr ""

msgid "![](images/30min_multipleeditors.png)"
msgstr ""

msgid "---"
msgstr ""

msgid ""
"**[Next Chapter: 15 Minutes Tutorial - Extended](103_domainmodelnextsteps.html"
")**"
msgstr ""
