msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: documentation\n"
"title: 15 Minutes Tutorial\n"
"part: Getting Started\n"
"---"
msgstr ""
"---\n"
"layout: documentation\n"
"title: 15分チュートリアル\n"
"part: はじめよう\n"
"---"

msgid "# {{page.title}} {#domain-model-walkthrough}"
msgstr "# {{page.title}} {#domain-model-walkthrough}"

msgid ""
"In this tutorial we will implement a small domain-specific language to model e"
"ntities and properties similar to what you may know from Rails, Grails or Spri"
"ng Roo. The syntax is very suggestive:"
msgstr ""
"このチュートリアルでは、Rails、GrailsやSpring Rooのように、エンティティとプロパティをモデル化するための小さなドメイン固有言語を実装しま"
"す。この構文はとても示唆に富んでいます。"

msgid ""
"```domainexample\n"
"datatype String"
msgstr ""
"```domainexample\n"
"datatype String"

msgid ""
"entity Blog {\n"
"    title: String\n"
"    many posts: Post\n"
"}"
msgstr ""
"entity Blog {\n"
"    title: String\n"
"    many posts: Post\n"
"}"

msgid ""
"entity HasAuthor {\n"
"    author: String\n"
"}"
msgstr ""
"entity HasAuthor {\n"
"    author: String\n"
"}"

msgid ""
"entity Post extends HasAuthor {\n"
"    title: String\n"
"    content: String\n"
"    many comments: Comment\n"
"}"
msgstr ""
"entity Post extends HasAuthor {\n"
"    title: String\n"
"    content: String\n"
"    many comments: Comment\n"
"}"

msgid ""
"entity Comment extends HasAuthor {\n"
"    content: String\n"
"}\n"
"```"
msgstr ""
"entity Comment extends HasAuthor {\n"
"    content: String\n"
"}\n"
"```"

msgid ""
"After you have installed Xtext on your machine, start Eclipse and set up a fre"
"sh workspace."
msgstr "あなたのマシーンにXtextをインストールした後、Eclipseを起動し、新規workspaceをセットアップします。"

msgid "## Create A New Xtext Project"
msgstr "## 新規Xtextプロジェクトの作成"

msgid ""
"In order to get started we first need to create some Eclipse projects. Use the"
" Eclipse wizard to do so:"
msgstr "まず初めに、Eclipseプロジェクトを作る必要があります。Eclipseウィザードから以下の操作を行います。"

msgid "*File &rarr; New &rarr; Project... &rarr; Xtext &rarr; Xtext project*"
msgstr "*File &rarr; New &rarr; Project... &rarr; Xtext &rarr; Xtext project*"

msgid "Choose a meaningful project name, language name and file extension, e.g."
msgstr "意味のあるプロジェクト名、言語名、そしてファイル拡張子を選びます。例えば"

msgid ""
"|:---|:---|\n"
"|**Project name:**|org.example.domainmodel|\n"
"|**Language name:**|org.example.domainmodel.Domainmodel|\n"
"|**DSL-File extensions:**|dmodel|"
msgstr ""
"|:---|:---|\n"
"|**プロジェクト名:**|org.example.domainmodel|\n"
"|**言語名:**|org.example.domainmodel.Domainmodel|\n"
"|**DSL-ファイル拡張子:**|dmodel|"

msgid "Click on *Finish* to create the projects."
msgstr "プロジェクトを作成するため *Finish* を押してください。"

msgid "![](images/30min_wizard.png)"
msgstr "![](../../documentation/images/30min_wizard.png)"

msgid ""
"After you have successfully finished the wizard, you will find five new projec"
"ts in your workspace."
msgstr "ウィザードを正常に終了した後、ワークスペースには5つの新しいプロジェクトが作成されます。"

msgid ""
"|:---|:---|\n"
"|org.example.domainmodel|The grammar definition and all language-specific comp"
"onents (parser, lexer, linker, validation, etc.)|\n"
"|org.example.domainmodel.ide|Platform-independent IDE functionality (e.g. serv"
"ices for content assist)|\n"
"|org.example.domainmodel.tests|Unit tests for the language|\n"
"|org.example.domainmodel.ui|The Eclipse editor and other workbench related fun"
"ctionality|\n"
"|org.example.domainmodel.ui.tests|UI tests for the Eclipse editor|"
msgstr ""
"|:---|:---|\n"
"|org.example.domainmodel| 文法定義と全ての言語固有コンポーネント(パーサー、字句解析器、リンカー、バリデーションなど)|\n"
"|org.example.domainmodel.ide| プラットフォームに依存しないIDE機能 (例 コンテントアシスタントサービス)|\n"
"|org.example.domainmodel.tests| 言語のユニットテスト|\n"
"|org.example.domainmodel.ui| Eclipseエディタと、ワークベンチ関連機能|\n"
"|org.example.domainmodel.ui.tests| Eclipseエディタ用UIテスト|"

msgid "![](images/30min_initialprojectlayout.png)"
msgstr "![](../../documentation/images/30min_initialprojectlayout.png)"

msgid "## Write The Grammar"
msgstr "## 文法を書く"

msgid ""
"The wizard will automatically open the grammar file *Domainmodel.xtext* in the"
" editor. As you can see it already contains a simple *Hello World* grammar:"
msgstr ""
"エディターで 文法ファイル*Domainmodel.xtext* を開くと、ウィザードが自動的に開きます。文法ファイルにはシンプルな *Hello Worl"
"d* 文法が含まれています。"

msgid ""
"```xtext\n"
"grammar org.example.domainmodel.Domainmodel with\n"
"                                      org.eclipse.xtext.common.Terminals"
msgstr ""
"```xtext\n"
"grammar org.example.domainmodel.Domainmodel with\n"
"                                      org.eclipse.xtext.common.Terminals"

msgid "generate domainmodel \"http://www.example.org/domainmodel/Domainmodel\""
msgstr "generate domainmodel \"http://www.example.org/domainmodel/Domainmodel\""

msgid ""
"Model:\n"
"    greetings+=Greeting*;"
msgstr ""
"Model:\n"
"    greetings+=Greeting*;"

msgid ""
"Greeting:\n"
"    'Hello' name=ID '!';\n"
"```"
msgstr ""
"Greeting:\n"
"    'Hello' name=ID '!';\n"
"```"

msgid ""
"Let's now just replace that grammar definition with the one for our entities l"
"anguage:"
msgstr "さっそく、文法定義をエンティティ言語で置き換えてみましょう。"

msgid ""
"Domainmodel:\n"
"    (elements+=Type)*;"
msgstr ""
"Domainmodel:\n"
"    (elements+=Type)*;"

msgid ""
"Type:\n"
"    DataType | Entity;"
msgstr ""
"Type:\n"
"    DataType | Entity;"

msgid ""
"DataType:\n"
"    'datatype' name=ID;"
msgstr ""
"DataType:\n"
"    'datatype' name=ID;"

msgid ""
"Entity:\n"
"    'entity' name=ID ('extends' superType=[Entity])? '{'\n"
"        (features+=Feature)*\n"
"    '}';"
msgstr ""
"Entity:\n"
"    'entity' name=ID ('extends' superType=[Entity])? '{'\n"
"        (features+=Feature)*\n"
"    '}';"

msgid ""
"Feature:\n"
"    (many?='many')? name=ID ':' type=[Type];\n"
"```"
msgstr ""
"Feature:\n"
"    (many?='many')? name=ID ':' type=[Type];\n"
"```"

msgid "Let's have a more detailed look at what the different grammar rules mean:"
msgstr "文法ルールの意味を詳しく見ていきましょう。"

msgid "1.  The first rule in a grammar is always used as the start rule."
msgstr "1.  文法の最初のルールは常にスタートルールとして使用されます。"

msgid ""
"    ```xtext\n"
"    Domainmodel:\n"
"        (elements+=Type)*;\n"
"    ```"
msgstr ""
"    ```xtext\n"
"    Domainmodel:\n"
"        (elements+=Type)*;\n"
"    ```"

msgid ""
"    It says that a *Domainmodel* contains an arbitrary number (`*`) of *Type*s"
" which are added (`+=`) to a feature called `elements`.\n"
"1.  The rule *Type* delegates to either the rule *DataType* or (`|`) the rule "
"*Entity*."
msgstr ""
"    これは、*Domainmodel* が任意の数の*Type*を持ち、それらを `elements`と呼ばれる特性に追加 (`+=`) することを表し"
"ています。\n"
"1.  *Type* ルールは*DataType* ルール もしくは (`|`) *Entity* ルールに委任します。"

msgid ""
"    ```xtext\n"
"    Type:\n"
"        DataType | Entity;\n"
"    ```"
msgstr ""
"    ```xtext\n"
"    Type:\n"
"        DataType | Entity;\n"
"    ```"

msgid ""
"1.  The rule *DataType* starts with a keyword `'datatype'`, followed by an ide"
"ntifier which is parsed by a rule called *ID*. The rule *ID* is defined in the"
" super grammar *org.eclipse.xtext.common.Terminals* and parses a single word, "
"a.k.a identifier. You can navigate to the declaration by using *F3* on the rul"
"e call. The value returned by the call to *ID* is assigned (`=`) to the featur"
"e `name`."
msgstr ""
"1.  *DataType* ルールは `'datatype'`キーワードから始まり、*ID* と呼ばれるルールによってパースされる識別子が続きます。*ID"
"* ルールは上位文法 *org.eclipse.xtext.common.Terminals* で定義され、一つの単語(識別子)をパースします。 ルールの呼"
"び出し箇所で *F3* を押すことで、宣言箇所にジャンプできます。*ID* の戻り値は 特性`name`に割り当てられます(`=`)。"

msgid ""
"    ```xtext\n"
"    DataType:\n"
"        'datatype' name=ID;\n"
"    ```"
msgstr ""
"    ```xtext\n"
"    DataType:\n"
"        'datatype' name=ID;\n"
"    ```"

msgid ""
"1.  The rule *Entity* again starts with the definition of a keyword followed b"
"y a name."
msgstr "1.  *Entity* ルールもキーワードの定義から始まり、次に名前が続きます。"

msgid ""
"    ```xtext\n"
"    Entity :\n"
"        'entity' name=ID ('extends' superType=[Entity])? '{'\n"
"            (features+=Feature)*\n"
"        '}';\n"
"    ```"
msgstr ""
"    ```xtext\n"
"    Entity :\n"
"        'entity' name=ID ('extends' superType=[Entity])? '{'\n"
"            (features+=Feature)*\n"
"        '}';\n"
"    ```"

msgid ""
"    Next up there is the `extends` clause which is parenthesized and optional "
"(`?`). Since the feature named `superType` is a cross reference (note the squa"
"re brackets), the parser rule *Entity* is not called here, but only a single i"
"dentifier (the *ID*-rule) is parsed. The actual *Entity* to assign to the `sup"
"erType` reference is resolved during the linking phase. Finally between curly "
"braces there can be any number of *Features*, which invokes the next rule.\n"
"1.  Last but not least, the rule *Feature* is defined as follows:"
msgstr ""
"    次に かっこで囲まれたオプション (`?`) の`extends` 句があります。 特性 `superType` は クロスリファレンス ( 角かっ"
"こに注意 )なので、 パーサールール *Entity* はここでは呼び出されず、一つの識別子だけが (*ID* ルール) がパースされます。`superTy"
"pe` で参照する実際の *Entity* 割り付けは、リンクフェーズにて解決されます。 最後に、 中かっこの中には、次のルールで呼び出される任意の数の *"
"Feature* を含めることができます。\n"
"1.  最後に、 *Feature* ルール定義は次のとおり:"

msgid ""
"    ```xtext\n"
"    Feature:\n"
"        (many?='many')? name=ID ':' type=[Type];\n"
"    ```"
msgstr ""
"    ```xtext\n"
"    Feature:\n"
"        (many?='many')? name=ID ':' type=[Type];\n"
"    ```"

msgid ""
"    The keyword `many` shall be used to model a multi-valued feature in this D"
"SL. The assignment operator (`?=`) implies that the feature `many` is of type "
"*boolean*. You are already familiar with the other syntax elements in this par"
"ser rule."
msgstr ""
"    `many` キーワードは、複数の値を持つ特性をモデル化するのに使われます。 代入演算子 (`?=`) は、`many` の型が *boolean*"
"であることを意味しています。 その他のパーサールールは既知のものです。"

msgid ""
"This entities grammar already uses the most important concepts of Xtext's gram"
"mar language. You have learned that keywords are written as string literals an"
"d a simple assignment uses a plain equal sign (`=`), whereas a multi-value ass"
"ignment uses a plus-equals (`+=`). We have also seen the boolean assignment op"
"erator (`?=`). Furthermore the example contains syntax elements with different"
" cardinalities (`?` = optional, `*` = any number, `+` = at least once) and dem"
"onstrates how cross-references can be declared. Please consult the [Grammar La"
"nguage Reference](301_grammarlanguage.html) for more details. Let's now have a"
" look what you can do with such a language description."
msgstr ""
"このエンティティ文法はすでにXtextの文法言語の最も重要な概念を使用しています。 キーワードは文字列リテラルとして記述され、単純な割り当てではイコール ("
"`=`) が用いられるが、複数値の割り付けにはプラスイコール (`+=`) が用いられます。 また、真偽値の割り当て符号 (`?=`) についても確認しまし"
"た。 さらに、この例では様々な構文要素 (`?` = オプション, `*` = 任意の数, `+` = 少なくとも1つ) を含んでおり、さらにクロスリファレ"
"ンスのデモを示しています。 詳細は、[文法言語リファレンス](301_grammarlanguage.html) を参照してください。 では、これらの言語記"
"述で何ができるのかを見ていきましょう。"

msgid "## Generate Language Artifacts"
msgstr "## 言語アーティファクトの生成"

msgid ""
"Now that we have the grammar in place we need to execute the code generator th"
"at will derive the various language components. To do so, right-click into the"
" grammar editor and select"
msgstr "文法の準備が整ったので、様々な言語要素を得るためコード生成を実行する必要があります。コード生成のためには、文法エディタ上で右クリックし以下を選択します。"

msgid "*Run As &rarr; Generate Xtext Artifacts*."
msgstr "*Run As &rarr; Generate Xtext Artifacts*."

msgid ""
"This action generates the parser and text editor and some additional infrastru"
"cture code. You will see its logging messages in the Console View."
msgstr ""
"この操作によって、パーサー、テキストエディタといくつかの追加のインフラストラクチャコードが生成され、これはらコンソールビューのログメッセージで確認することが"
"できます。"

msgid "![](images/30min_rungenerator.png)"
msgstr "![](../../documentation/images/30min_rungenerator.png)"

msgid "## Run the Generated Eclipse Plug-in {#run-generated-plugin}"
msgstr "## 生成されたEclipseプラグインの実行 {#run-generated-plugin}"

msgid ""
"We are now able to test the Eclipse IDE integration. If you right-click the pr"
"oject `org.example.domainmodel` in the Package Explorer and select *Run As &ra"
"rr; Eclipse Application*, a new run configuration is created and launched that"
" starts a second instance of Eclipse including your new language plug-ins. In "
"the new instance, create a new project of your choice, e.g. *File &rarr; New &"
"rarr; Project... &rarr; Java Project* and therein a new file with the file ext"
"ension you chose in the beginning (*\\*.dmodel*). This will open the generated "
"entity editor. Try it and discover the default functionality for code completi"
"on, syntax highlighting, syntactic validation, linking errors, formatting, (qu"
"ick) outline view, hyperlinking, find references, folding, rename refactoring "
"etc."
msgstr ""
"Eclipse IDE統合の準備ができました。パッケージエクスプローラのプロジェクト `org.example.domainmodel` を右クリックし、*"
"Run As &rarr; Eclipse Application*を選択すると、新規run configurationが生成され、新たな言語プラグインが組"
"み込まれた2つ目のEclipseインスタンスが表示されます。表示されたEclipseインスタンスにて*File &rarr; New &rarr; Proj"
"ect... &rarr; Java Project*を実行し、新規プロジェクトを作成します。その後、拡張子が (*\\*.dmodel*) から始まるファイ"
"ルを作成すると、生成したエンティティエディタが開きます。では、コード補間、シンタックスハイライティング、構文チェック、リンクエラー、フォーマッティング、(ク"
"イック)アウトラインビュー、ハイパーリンキング、参照の発見、折り畳み、リネームリファクタリングなどの標準機能を確認しましょう。"

msgid "![](images/30min_editor.png)"
msgstr "![](../../documentation/images/30min_editor.png)"

msgid "## Second Iteration: Adding Packages and Imports {#add-imports}"
msgstr "## 第2イテレーション: パッケージの追加とインポート {#add-imports}"

msgid ""
"After you have created your first DSL and had a look at the editor, the langua"
"ge should be refined and incrementally enhanced. The domainmodel language shou"
"ld support the notion of *Packages* in order to avoid name clashes and to bett"
"er fit with the target environment Java. A *Package* may contain *Types* and o"
"ther packages. In order to allow for names in references, we will also add a w"
"ay to declare imports."
msgstr ""
"最初のDSLを生成しエディタの表示を確認したので、言語の改良、機能追加をしていきましょう。domainmodel言語は名前の衝突を避けることとJavaとの親"
"和性を高めるために*Packages*の概念をサポートする必要があります。*Package* は *Types* と他のパッケージを含みます。さらに名前によ"
"る参照を実現するため、imports宣言も追加します。"

msgid ""
"In the end we want to be able to split the previously used model into distinct"
" files:"
msgstr "最後に、これまで使っていたモデルを異なるファイルに分割します。"

msgid ""
"```domainexample\n"
"// datatypes.dmodel"
msgstr ""
"```domainexample\n"
"// datatypes.dmodel"

msgid ""
"datatype String\n"
"```"
msgstr ""
"datatype String\n"
"```"

msgid ""
"```domainexample\n"
"// commons.dmodel"
msgstr ""
"```domainexample\n"
"// commons.dmodel"

msgid "package my.company.common {"
msgstr "package my.company.common {"

msgid ""
"    entity HasAuthor {\n"
"        author: String\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    entity HasAuthor {\n"
"        author: String\n"
"    }\n"
"}\n"
"```"

msgid ""
"```domainexample\n"
"// blogs.dmodel"
msgstr ""
"```domainexample\n"
"// blogs.dmodel"

msgid "package my.company.blog {"
msgstr "package my.company.blog {"

msgid "    import my.company.common.*"
msgstr "    import my.company.common.*"

msgid ""
"    entity Blog {\n"
"        title: String\n"
"        many posts: Post\n"
"    }"
msgstr ""
"    entity Blog {\n"
"        title: String\n"
"        many posts: Post\n"
"    }"

msgid ""
"    entity Post extends my.company.common.HasAuthor {\n"
"        title: String\n"
"        content: String\n"
"        many comments: Comment\n"
"    }"
msgstr ""
"    entity Post extends my.company.common.HasAuthor {\n"
"        title: String\n"
"        content: String\n"
"        many comments: Comment\n"
"    }"

msgid ""
"    entity Comment extends HasAuthor {\n"
"        content: String\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    entity Comment extends HasAuthor {\n"
"        content: String\n"
"    }\n"
"}\n"
"```"

msgid "Let's start enhancing the grammar."
msgstr "文法を改良しましょう。"

msgid ""
"1.  Since a *Domainmodel* no longer contains types but also packages, the entr"
"y rule has to be modified. Furthermore, a common super type for *PackageDeclar"
"ations* and *Types* should be introduced: the *AbstractElement*."
msgstr ""
"1.  *Domainmodel* は型とパッケージは含まれているので、エントリールールを変更する必要があります。さらに、*PackageDeclarati"
"ons* と *Types* に対する上位の共通型(*AbstractElement*)も導入する必要があります。"

msgid ""
"    ```xtext\n"
"    Domainmodel:\n"
"        (elements+=AbstractElement)*;"
msgstr ""
"    ```xtext\n"
"    Domainmodel:\n"
"        (elements+=AbstractElement)*;"

msgid ""
"    AbstractElement:\n"
"        PackageDeclaration | Type;\n"
"    ```"
msgstr ""
"    AbstractElement:\n"
"        PackageDeclaration | Type;\n"
"    ```"

msgid ""
"1.  A `PackageDeclaration` in turn looks pretty much as expected. It contains "
"a number of *Imports* and *AbstractElements*. Since *Imports* should be allowe"
"d for the root-Domainmodel, too, we add them as an alternative to the rule `Ab"
"stractElement`."
msgstr ""
"1.  `PackageDeclaration`は期待通りに見えます。これは、複数の *Imports* と *AbstractElements* を含みま"
"す。*Imports* もまたルートドメインモデルに含まれる必要があるため、`AbstractElement` のルールに追加します。"

msgid ""
"    ```xtext\n"
"    PackageDeclaration:\n"
"        'package' name=QualifiedName '{'\n"
"            (elements+=AbstractElement)*\n"
"        '}';"
msgstr ""
"    ```xtext\n"
"    PackageDeclaration:\n"
"        'package' name=QualifiedName '{'\n"
"            (elements+=AbstractElement)*\n"
"        '}';"

msgid ""
"    AbstractElement:\n"
"        PackageDeclaration | Type | Import;"
msgstr ""
"    AbstractElement:\n"
"        PackageDeclaration | Type | Import;"

msgid ""
"    QualifiedName:\n"
"        ID ('.' ID)*;\n"
"    ```"
msgstr ""
"    QualifiedName:\n"
"        ID ('.' ID)*;\n"
"    ```"

msgid ""
"    The `QualifiedName` is a little special. It does not contain any assignmen"
"ts. Therefore it serves as a data type rule that returns a String. Hence the f"
"eature `name` of a *Package* is still of type [String]({{site.javadoc.java}}/j"
"ava/lang/String.html).\n"
"1.  Imports can be defined in a very convenient way with Xtext. If you use the"
" name `importedNamespace` in a parser rule, the framework will treat the value"
" as an import. It even supports wildcards and handles them as expected:"
msgstr ""
"    `QualifiedName` は少し特殊で、割り当てが含まれません。したがって、これは文字列を返すデータタイプルールを提供します。よって、 *Pa"
"ckage*の`name`特性は[String]({{site.javadoc.java}}/java/lang/String.html)型のままです。\n"
"1.  ImportsはXtextによってとても簡単に定義することができます。パーサールールで`importedNamespace`という名前を用いると、フ"
"レームワークはimportとして処理します。これはワイルドカードもサポートしています。"

msgid ""
"    ```xtext\n"
"    Import:\n"
"        'import' importedNamespace=QualifiedNameWithWildcard;"
msgstr ""
"    ```xtext\n"
"    Import:\n"
"        'import' importedNamespace=QualifiedNameWithWildcard;"

msgid ""
"    QualifiedNameWithWildcard:\n"
"        QualifiedName '.*'?;\n"
"    ```"
msgstr ""
"    QualifiedNameWithWildcard:\n"
"        QualifiedName '.*'?;\n"
"    ```"

msgid ""
"    Similar to the rule `QualifiedName`, `QualifiedNameWithWildcard` returns a"
" plain string.\n"
"1.  The last step is to allow fully qualified names in cross-references, too. "
"Otherwise one could not refer to an entity without adding an import statement."
msgstr ""
"    `QualifiedName`と同様に、`QualifiedNameWithWildcard`もまたもプレーン文字列を返します。\n"
"1.  最後のステップでは、完全修飾名をクロスリファレンスでも使用できるようにします。これがないと、importを常に記載しないとエンティティの参照ができな"
"くなります。"

msgid ""
"    ```xtext\n"
"    Entity:\n"
"        'entity' name=ID ('extends' superType=[Entity|QualifiedName])? '{'\n"
"            (features+=Feature)*\n"
"        '}';"
msgstr ""
"    ```xtext\n"
"    Entity:\n"
"        'entity' name=ID ('extends' superType=[Entity|QualifiedName])? '{'\n"
"            (features+=Feature)*\n"
"        '}';"

msgid ""
"    Feature:\n"
"        (many?='many')? name=ID ':' type=[Type|QualifiedName];\n"
"    ```"
msgstr ""
"    Feature:\n"
"        (many?='many')? name=ID ':' type=[Type|QualifiedName];\n"
"    ```"

msgid ""
"    Please note that the bar (`|`) is not an alternative in the context of a c"
"ross-reference, but used to specify the syntax of the parsed string."
msgstr "    (`|`)はクロスリファレンスの対象ではなく、パースされた文字列の構文を指定するために用いられることに注意してください。"

msgid "That's all for the grammar. It should now read as"
msgstr "文法は以上です。最終的に以下のようになります。"

msgid ""
"Domainmodel:\n"
"    (elements+=AbstractElement)*;"
msgstr ""
"Domainmodel:\n"
"    (elements+=AbstractElement)*;"

msgid ""
"PackageDeclaration:\n"
"    'package' name=QualifiedName '{'\n"
"        (elements+=AbstractElement)*\n"
"    '}';"
msgstr ""
"PackageDeclaration:\n"
"    'package' name=QualifiedName '{'\n"
"        (elements+=AbstractElement)*\n"
"    '}';"

msgid ""
"AbstractElement:\n"
"    PackageDeclaration | Type | Import;"
msgstr ""
"AbstractElement:\n"
"    PackageDeclaration | Type | Import;"

msgid ""
"QualifiedName:\n"
"    ID ('.' ID)*;"
msgstr ""
"QualifiedName:\n"
"    ID ('.' ID)*;"

msgid ""
"Import:\n"
"    'import' importedNamespace=QualifiedNameWithWildcard;"
msgstr ""
"Import:\n"
"    'import' importedNamespace=QualifiedNameWithWildcard;"

msgid ""
"QualifiedNameWithWildcard:\n"
"    QualifiedName '.*'?;"
msgstr ""
"QualifiedNameWithWildcard:\n"
"    QualifiedName '.*'?;"

msgid ""
"Entity:\n"
"    'entity' name=ID ('extends' superType=[Entity|QualifiedName])? '{'\n"
"        (features+=Feature)*\n"
"    '}';"
msgstr ""
"Entity:\n"
"    'entity' name=ID ('extends' superType=[Entity|QualifiedName])? '{'\n"
"        (features+=Feature)*\n"
"    '}';"

msgid ""
"Feature:\n"
"    (many?='many')? name=ID ':' type=[Type|QualifiedName];\n"
"```"
msgstr ""
"Feature:\n"
"    (many?='many')? name=ID ':' type=[Type|QualifiedName];\n"
"```"

msgid ""
"You should regenerate the language infrastructure as described in the previous"
" section, and give the editor another try. You can even split up your model in"
"to smaller parts and have cross-references across file boundaries."
msgstr ""
"上記の変更をエディタに反映させるためには、前のセクションで紹介した言語インフラストラクチャの生成を再度行う必要があります。また、モデルを小さなパーツに分割し"
"、ファイルの境界を越えてクロスリファレンスすることも可能です。"

msgid "![](images/30min_multipleeditors.png)"
msgstr "![](../../documentation/images/30min_multipleeditors.png)"

msgid "---"
msgstr "---"

msgid ""
"**[Next Chapter: 15 Minutes Tutorial - Extended](103_domainmodelnextsteps.html"
")**"
msgstr "**[次章: 15分チュートリアル - 拡張](103_domainmodelnextsteps.html)**"
