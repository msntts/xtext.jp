msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: documentation\n"
"title: Five simple steps to your JVM language\n"
"part: Getting Started\n"
"---"
msgstr ""

msgid "# {{page.title}} {#jvm-domain-model}"
msgstr ""

msgid ""
"In this tutorial we will basically implement the [domain model language](https"
"://www.eclipse.org/Xtext/documentation/103_domainmodelnextsteps.html) again, b"
"ut this time we will make use of the special JVM support shipped with Xtext. T"
"his kind of language is really a sweet spot for DSLs, so feel free to use this"
" as a blueprint and add your project specific features later on."
msgstr ""

msgid ""
"The revised domain model language supports expressions and cross-links to Java"
" types. It is directly translated to Java source code. The syntax should look "
"very familiar. Here is an example:"
msgstr ""

msgid ""
"```domainexample\n"
"import java.util.List"
msgstr ""

msgid "package my.model {"
msgstr ""

msgid ""
"    entity Person {\n"
"        name: String\n"
"        firstName: String\n"
"        friends: List<Person>\n"
"        address : Address\n"
"        op getFullName() : String {\n"
"            return firstName + \" \" + name;\n"
"        }"
msgstr ""

msgid ""
"        op getFriendsSortedByFullName() : List<Person> {\n"
"            return friends.sortBy[ f | f.fullName ]\n"
"        }\n"
"    }"
msgstr ""

msgid ""
"    entity Address {\n"
"        street: String\n"
"        zip: String\n"
"        city: String\n"
"    }\n"
"}\n"
"```"
msgstr ""

msgid ""
"As you can see, it supports all kinds of advanced features such as Java generi"
"cs and full expressions, even including lambda expressions. Don't panic, you w"
"ill not have to implement these concepts on your own but will reuse a lot of h"
"elpful infrastructure to build the language."
msgstr ""

msgid ""
"We will now walk through the five little steps needed to get this language ful"
"ly working including its compiler. The first three steps are very similar to t"
"hose in the [15 Minutes Tutorial](102_domainmodelwalkthrough.html)."
msgstr ""

msgid ""
"After you have installed Xtext on your machine, start Eclipse and set up a fre"
"sh workspace."
msgstr ""

msgid "## Step One: Create A New Xtext Project {#domain-model-step1}"
msgstr ""

msgid ""
"In order to get started we first need to create some Eclipse projects. Use the"
" Eclipse wizard to do so:"
msgstr ""

msgid "*File &rarr; New &rarr; Project... &rarr; Xtext &rarr; Xtext Project*"
msgstr ""

msgid "Choose a meaningful project name, language name and file extension, e.g."
msgstr ""

msgid ""
"|:---|:---|\n"
"|**Project name:**|org.example.domainmodel|\n"
"|**Language name:**|org.example.domainmodel.Domainmodel|\n"
"|**File extension:**|dmodel|"
msgstr ""

msgid "Click on *Finish* to create the projects"
msgstr ""

msgid "![](images/30min_wizard.png)"
msgstr ""

msgid ""
"After you have successfully finished the wizard, you will find five new projec"
"ts in your workspace."
msgstr ""

msgid ""
"|:---|:---|\n"
"|org.example.domainmodel|The grammar definition and all language-specific comp"
"onents (parser, lexer, linker, validation, etc.)|\n"
"|org.example.domainmodel.tests|Unit tests for the language|\n"
"|org.example.domainmodel.ide|Platform-independent IDE functionality (e.g. serv"
"ices for content assist)|\n"
"|org.example.domainmodel.ui|The Eclipse editor and other workbench related fun"
"ctionality|\n"
"|org.example.domainmodel.ui.tests|Unit tests for the Eclipse editor|"
msgstr ""

msgid "![](images/30min_initialprojectlayout.png)"
msgstr ""

msgid "## Step Two: Write the Grammar {#domain-model-step2}"
msgstr ""

msgid ""
"The wizard will automatically open the grammar file *Domainmodel.xtext* in the"
" editor. As you can see it already contains a simple *Hello World* grammar. Re"
"place that grammar definition with the one for our language:"
msgstr ""

msgid ""
"```xtext\n"
"grammar org.example.domainmodel.Domainmodel with\n"
"                                      org.eclipse.xtext.xbase.Xbase"
msgstr ""

msgid "generate domainmodel \"http://www.example.org/domainmodel/Domainmodel\""
msgstr ""

msgid ""
"Domainmodel:\n"
"    importSection=XImportSection?\n"
"    elements+=AbstractElement*;"
msgstr ""

msgid ""
"AbstractElement:\n"
"    PackageDeclaration | Entity;"
msgstr ""

msgid ""
"PackageDeclaration:\n"
"    'package' name=QualifiedName '{'\n"
"        elements+=AbstractElement*\n"
"    '}';"
msgstr ""

msgid ""
"Entity:\n"
"    'entity' name=ValidID ('extends' superType=JvmTypeReference)? '{'\n"
"        features+=Feature*\n"
"    '}';"
msgstr ""

msgid ""
"Feature:\n"
"    Property | Operation;"
msgstr ""

msgid ""
"Property:\n"
"    name=ValidID ':' type=JvmTypeReference;"
msgstr ""

msgid ""
"Operation:\n"
"    'op' name=ValidID \n"
"        '('(params+=FullJvmFormalParameter \n"
"        (',' params+=FullJvmFormalParameter)*)?')'\n"
"        ':' type=JvmTypeReference \n"
"    body=XBlockExpression;"
msgstr ""

msgid "```"
msgstr ""

msgid ""
"Some parts of this grammar are equal to the one in the [15 Minutes Tutorial](1"
"02_domainmodelwalkthrough.html), but other parts are different."
msgstr ""

msgid "1."
msgstr ""

msgid ""
"    ```xtext\n"
"    grammar org.example.domainmodel.Domainmodel with\n"
"                  org.eclipse.xtext.xbase.Xbase\n"
"    ```"
msgstr ""

msgid ""
"    The first thing to note is that instead of inheriting from the usual *org."
"eclipse.xtext.common.Terminals* grammar, we make use of *org.eclipse.xtext.xba"
"se.Xbase*. Xbase allows us to easily reuse and embed modern, statically typed "
"expressions as well as Java type signatures in our language."
msgstr ""

msgid ""
"    ```xtext\n"
"    Domainmodel:\n"
"        importSection=XImportSection?\n"
"        elements+=AbstractElement*;\n"
"    ```"
msgstr ""

msgid ""
"    A *Domainmodel* contains an optional import section and an arbitrary numbe"
"r of *AbstractElements*. The concept of *XImportSection* is part of *org.eclip"
"se.xtext.xbase.Xbase* and comes with tool support and syntax like you know it "
"from Java.\n"
"1."
msgstr ""

msgid ""
"    ```xtext\n"
"    AbstractElement:\n"
"        PackageDeclaration | Entity;\n"
"    ```"
msgstr ""

msgid ""
"    The rule *AbstractElement* delegates to either the rule *PackageDeclaratio"
"n* or the rule *Entity*.\n"
"1."
msgstr ""

msgid ""
"    ```xtext\n"
"    PackageDeclaration:\n"
"        'package' name=QualifiedName '{'\n"
"            elements+=AbstractElement*\n"
"        '}';\n"
"    ```"
msgstr ""

msgid ""
"    A *PackageDeclaration* is used to declare a name space which can again con"
"tain any number of *AbstractElement*s. Xtext has built-in support for qualifie"
"d names and scoping based on the hierarchy of the produced model. The default "
"implementation will add the package names as the prefix to contained entities "
"and nested packages. The qualified name of an *Entity* 'Baz' which is containe"
"d in a *PackageDeclaration* 'foo.bar' will be 'foo.bar.Baz'. In case you do no"
"t like the default behavior you will need to use a different implementation of"
" [IQualifiedNameProvider]({{site.src.xtext_core}}/org.eclipse.xtext/src/org/ec"
"lipse/xtext/naming/IQualifiedNameProvider.java).\n"
"1."
msgstr ""

msgid ""
"    ```xtext\n"
"    Entity:\n"
"        'entity' name=ValidID ('extends' superType=JvmTypeReference)? '{'\n"
"            features+=Feature*\n"
"        '}';\n"
"    ```"
msgstr ""

msgid ""
"    The rule *Entity* starts with the definition of a keyword followed by a na"
"me. The *extends* clause makes use of the rule *JvmTypeReference* which is def"
"ined in the super grammar. *JvmTypeReference* defines the syntax for full Java"
"-like type names. That is everything from simple names, over fully qualified n"
"ames to fully-fledged generics, including wildcards, lower bounds and upper bo"
"unds. Finally between curly braces there can be any number of *Features*, whic"
"h leads us to the next rule.\n"
"1."
msgstr ""

msgid ""
"    ```xtext\n"
"    Feature:\n"
"        Property | Operation;\n"
"    ```"
msgstr ""

msgid ""
"    The rule *Feature* delegates to either a *Property* or an *Operation*.\n"
"1."
msgstr ""

msgid ""
"    ```xtext\n"
"    Property:\n"
"        name=ValidID ':' type=JvmTypeReference;\n"
"    ```"
msgstr ""

msgid ""
"    A *Property* has a name and makes again use of the inherited rule *JvmType"
"Reference*.\n"
"1."
msgstr ""

msgid ""
"    ```xtext\n"
"    Operation:\n"
"        'op' name=ValidID \n"
"            '('(params+=FullJvmFormalParameter \n"
"            (',' params+=FullJvmFormalParameter)*)?')'\n"
"            ':' type=JvmTypeReference \n"
"        body=XBlockExpression;\n"
"    ```"
msgstr ""

msgid ""
"    *Operation*s also have a signature as expected. Note that also for formal "
"parameters we can reuse a rule from the super grammar."
msgstr ""

msgid ""
"    The body of the *Operation* is the actual implementation and is defined by"
" the rule *XBlockExpression*, which is one of the most often used entry rules "
"from Xbase. A block consist of any number of expressions between curly braces "
"such as:"
msgstr ""

msgid ""
"    ```xbase\n"
"    {\n"
"        return \"Hello World\" + \"!\"\n"
"    }\n"
"    ```"
msgstr ""

msgid "## Step Three: Generate Language Artifacts {#domain-model-step3}"
msgstr ""

msgid ""
"Now that we have the grammar in place we need to execute the code generator th"
"at will derive the various language components. To do so, right-click into the"
" grammar editor and select"
msgstr ""

msgid "*Run As &rarr; Generate Xtext Artifacts*."
msgstr ""

msgid ""
"This action generates the parser and text editor and some additional infrastru"
"cture code. You will see its logging messages in the Console View."
msgstr ""

msgid "![](images/JvmTutorial_RunGenerator.png)"
msgstr ""

msgid "## Step Four: Define the Mapping to JVM Concepts {#domain-model-step4}"
msgstr ""

msgid ""
"The syntax alone is not enough to make the language work. We need to map the d"
"omain-specific concepts to some other language in order to instruct Xtext how "
"it is executed. Usually you define a code generator or an interpreter for that"
" matter, but languages using Xbase can omit this step and make use of the [IJv"
"mModelInferrer]({{site.src.xtext_extras}}/org.eclipse.xtext.xbase/src/org/ecli"
"pse/xtext/xbase/jvmmodel/IJvmModelInferrer.java)."
msgstr ""

msgid ""
"The idea is that you translate your language concepts to any number of Java ty"
"pes ([JvmDeclaredType]({{site.src.xtext_extras}}/org.eclipse.xtext.common.type"
"s/emf-gen/org/eclipse/xtext/common/types/JvmDeclaredType.java)). Such a type c"
"an be a Java class, Java interface, Java annotation type or a Java enum and ma"
"y contain any valid members. In the end you as a language developer are respon"
"sible to create a correct model according to the Java language."
msgstr ""

msgid ""
"By mapping your language concepts to Java elements, you implicitly tell Xtext "
"in what kind of scopes the various expressions live and what return types are "
"expected from them. Xtext also comes with a code generator which can translate"
" that Java model into readable Java code, including the expressions."
msgstr ""

msgid ""
"If you have already triggered the 'Generate Xtext Artifacts' action, you shoul"
"d find a stub called *org/example/domainmodel/jvmmodel/DomainmodelJvmModelInfe"
"rrer.xtend* in the src folder. Please replace its contents with the following "
":"
msgstr ""

msgid ""
"```xtend\n"
"package org.example.domainmodel.jvmmodel"
msgstr ""

msgid ""
"import com.google.inject.Inject\n"
"import org.example.domainmodel.domainmodel.Entity\n"
"import org.example.domainmodel.domainmodel.Operation\n"
"import org.example.domainmodel.domainmodel.Property\n"
"import org.eclipse.xtext.naming.IQualifiedNameProvider\n"
"import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer\n"
"import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor\n"
"import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder"
msgstr ""

msgid "class DomainmodelJvmModelInferrer extends AbstractModelInferrer {"
msgstr ""

msgid ""
"  /**\n"
"   * a builder API to programmatically create Jvm elements \n"
"   * in readable way.\n"
"   */\n"
"  @Inject extension JvmTypesBuilder"
msgstr ""

msgid "  @Inject extension IQualifiedNameProvider"
msgstr ""

msgid ""
"  def dispatch void infer(Entity element,\n"
"                IJvmDeclaredTypeAcceptor acceptor,\n"
"                boolean isPrelinkingPhase) {\n"
"    acceptor.accept(element.toClass( element.fullyQualifiedName )) [\n"
"      documentation = element.documentation\n"
"      if (element.superType !== null)\n"
"        superTypes += element.superType.cloneWithProxies\n"
"      for (feature : element.features) {\n"
"        switch feature {"
msgstr ""

msgid ""
"          Property : {\n"
"            members += feature.toField(feature.name, feature.type)\n"
"            members += feature.toGetter(feature.name, feature.type)\n"
"            members += feature.toSetter(feature.name, feature.type)\n"
"          }"
msgstr ""

msgid ""
"          Operation : {\n"
"            members += feature.toMethod(feature.name, feature.type) [\n"
"              documentation = feature.documentation\n"
"              for (p : feature.params) {\n"
"                parameters += p.toParameter(p.name, p.parameterType)\n"
"              }\n"
"              body = feature.body\n"
"            ]\n"
"          }\n"
"        }\n"
"      }\n"
"    ]\n"
"  }\n"
"}\n"
"```"
msgstr ""

msgid ""
"Let's go through the code to get an idea of what is going on. (Please also ref"
"er to the JavaDoc of the used API for details, especially the [JvmTypesBuilder"
"]({{site.src.xtext_extras}}/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbas"
"e/jvmmodel/JvmTypesBuilder.java))."
msgstr ""

msgid ""
"1.  ```xtend\n"
"    def dispatch void infer(Entity element,\n"
"            IJvmDeclaredTypeAcceptor acceptor,\n"
"            boolean isPrelinkingPhase) {\n"
"    ```"
msgstr ""

msgid ""
"    Using the dispatch keyword makes sure that the method is called for instan"
"ces of type *Entity* only. Have a look at the Xtend documentation on [polymorp"
"hic dispatch](http://www.eclipse.org/xtend/documentation/202_xtend_classes_mem"
"bers.html#polymorphic-dispatch) to understand Xtend's dispatch functions. Exte"
"nding [AbstractModelInferrer]({{site.src.xtext_extras}}/org.eclipse.xtext.xbas"
"e/src/org/eclipse/xtext/xbase/jvmmodel/AbstractModelInferrer.java) makes sure "
"we don't have to walk the syntax model on our own.\n"
"1.  ```xtend\n"
"    acceptor.accept(element.toClass(element.fullyQualifiedName)) [\n"
"        ...\n"
"    ]\n"
"    ```"
msgstr ""

msgid ""
"    Every [JvmDeclaredType]({{site.src.xtext_extras}}/org.eclipse.xtext.common"
".types/emf-gen/org/eclipse/xtext/common/types/JvmDeclaredType.java) you create"
" in the model inference needs to be passed to the *acceptor* in order to get r"
"ecognized. The extension method *toClass* comes from the [JvmTypesBuilder]({{s"
"ite.src.xtext_extras}}/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvm"
"model/JvmTypesBuilder.java) class. This class provides a lot of convenient ext"
"ension methods, which help making the code extremely readable and concise. It "
"is important to understand that the creation and assignment of a qualified nam"
"e is done in an early phase where the compiler collects all global symbols. Yo"
"u cannot resolve type references at this point.\n"
"1.  The second argument to *accept* is a lambda block that contains further in"
"itialization of the created Java type. Only in this block you are allowed to d"
"o type reference resolution. This is also the place where you add members and "
"put the XExpressions into context. Let's see what we do in the initialization "
"block in detail:\n"
"1.  ```xtend\n"
"    documentation = element.documentation\n"
"    ```"
msgstr ""

msgid ""
"    Here we assign some JavaDoc to the newly created element. The assignment i"
"s translated to an invocation of the method *[JvmTypesBuilder]({{site.src.xtex"
"t_extras}}/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/JvmTyp"
"esBuilder.java).setDocumentation([JvmIdentifiableElement]({{site.src.xtext_ext"
"ras}}/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/Jv"
"mIdentifiableElement.java), String)*, and `element.documentation` is in fact c"
"alling the extension method *[JvmTypesBuilder]({{site.src.xtext_extras}}/org.e"
"clipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.java)."
"getDocumentation([EObject]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/"
"org/eclipse/emf/ecore/EObject.java))*. Such extension methods are explained in"
" detail in the [Xtend documentation](https://www.eclipse.org/xtend/documentati"
"on/202_xtend_classes_members.html#extension-methods).\n"
"1.  ```xtend\n"
"    if (element.superType !== null)\n"
"        superTypes += entity.superType.cloneWithProxies\n"
"    ```"
msgstr ""

msgid ""
"    Set the *superType* on the inferred element. Note that we have to clone th"
"e type reference from the *element.superType*. If we did not do that, the type"
" reference would be automatically removed from the *element*, as *superType* i"
"s an EMF containment reference.\n"
"1.  ```xtend\n"
"    for (feature : element.features) {\n"
"        switch feature {\n"
"            Property : {\n"
"                // ...\n"
"            }\n"
"            Operation : {\n"
"                // ...\n"
"            }\n"
"        }\n"
"    }\n"
"    ```"
msgstr ""

msgid ""
"    When iterating over a list of heterogeneous types, the switch expression w"
"ith its type guards comes in handy. If *feature* is of type *Property* the fir"
"st block is executed. If it is an *Operation* the second block is executed. No"
"te that the variable *feature* will be implicitly casted to the respective typ"
"e within the blocks.\n"
"1.  ```xtend\n"
"    Property : {\n"
"        members += feature.toField(feature.name, feature.type)\n"
"        members += feature.toSetter(feature.name, feature.type)\n"
"        members += feature.toGetter(feature.name, feature.type)\n"
"    }\n"
"    ```"
msgstr ""

msgid ""
"    For each *Property* we create a field as well as a corresponding getter an"
"d setter.\n"
"1.  ```xtend\n"
"    Operation : {\n"
"        members += feature.toMethod(feature.name, feature.type) [\n"
"            documentation = feature.documentation\n"
"            for (p : feature.params) {\n"
"                parameters += p.toParameter(p.name, p.parameterType)\n"
"            }\n"
"            body = feature.body\n"
"        ]\n"
"    }\n"
"    ```"
msgstr ""

msgid ""
"    *Operations* are mapped to a corresponding Java method. The documentation "
"is translated and the parameters are added within the initializer. The line `b"
"ody = feature.body` registers the *Operation*'s expression as the body of the "
"newly created Java method. This defines the scope of the expression. The frame"
"work deduces the visible fields and parameters as well as the expected return "
"type from that information."
msgstr ""

msgid "## Step Five : Try the Editor! {#domain-model-step5}"
msgstr ""

msgid ""
"We are now able to test the IDE integration by spawning a new Eclipse using ou"
"r plug-ins: right-click the project `org.example.domainmodel` in the Package E"
"xplorer and select *Run As &rarr; Eclipse Application*."
msgstr ""

msgid ""
"In the new workbench, create a Java project (*File &rarr; New &rarr; Project.."
". &rarr; Java Project*). Xbase relies on a small runtime library on the class "
"path. To add this, right-click on the project and go to *Java Build Path &rarr"
"; Libraries &rarr; Add Library* and choose *Xtend Library*. Then create a new "
"file with the file extension you chose in the beginning (*\\*.dmodel*) in the s"
"ource folder of the Java project. This will open the generated entity editor. "
"Try it and discover the rich editor functionality it provides. You should also"
" have a look at the preferences of your language to find out what can be indiv"
"idually configured to your users needs."
msgstr ""

msgid "Have fun!"
msgstr ""

msgid "![](images/JvmTutorial_Editor.png)"
msgstr ""

msgid "---"
msgstr ""

msgid "**[Next Chapter: The Grammar Language](301_grammarlanguage.html)**"
msgstr ""
