# Japanese translations for PACKAGE package.
# Copyright (C) 2021 THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# msntts <terzonome-github@yahoo.co.jp>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-05 02:33-0500\n"
"PO-Revision-Date: 2021-06-05 02:33-0500\n"
"Last-Translator: msntts <terzonome-github@yahoo.co.jp>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../../documentation/301_grammarlanguage.md:1
msgid ""
"---\n"
"layout: documentation\n"
"title: The Grammar Language\n"
"part: Reference Documentation\n"
"---"
msgstr ""
"---\n"
"layout: documentation\n"
"title: 文法言語\n"
"part: リファレンスドキュメント\n"
"---"

#: ../../../documentation/301_grammarlanguage.md:7
msgid "# {{page.title}} {#grammarLanguage}"
msgstr "# {{page.title}} {#grammarLanguage}"

#: ../../../documentation/301_grammarlanguage.md:9
msgid "The [grammar language]({{site.src.xtext_core}}/org.eclipse.xtext/src/org/eclipse/xtext/Xtext.xtext) is the corner stone of Xtext. It is a domain-specific language, carefully designed for the description of textual languages. The main idea is to describe the concrete syntax and how it is mapped to an in-memory representation &ndash; the semantic model. This model will be created by the parser on-the-fly when it consumes an input file. Of course the Xtext grammar language itself is implemented with Xtext, so you will find parts of its syntax described with its own means in this documentation."
msgstr "[文法言語]({{site.src.xtext_core}}/org.eclipse.xtext/src/org/eclipse/xtext/Xtext.xtext)はXtextの基礎であり、テキスト言語の記述のために注意深く設計されたドメイン固有言語です。主な目的は、具象的な構文とメモリ内表現(つまり意味モデル)がどのようにマッピングされるかを記述することです。このモデルはファイル入力を受けると即座にパーサーによって生成されます。もちろん、Xtext文法言語そのものがXtextによって実装されているので、このドキュメント内に構文の説明を見つけることができます。"

#: ../../../documentation/301_grammarlanguage.md:11
msgid "An example grammar is shown in the [15 Minutes Tutorial](102_domainmodelwalkthrough.html#write-your-own-grammar)"
msgstr "文法の例は [15分チュートリアル](102_domainmodelwalkthrough.html#write-your-own-grammar)で確認することができます。"

#: ../../../documentation/301_grammarlanguage.md:13
msgid "## The Syntax {#syntax}"
msgstr "## 構文 {#syntax}"

#: ../../../documentation/301_grammarlanguage.md:15
msgid "In the following the different concepts and syntactical constructs of the grammar language are explained."
msgstr "以下に、複数の概念と文法言語の構文構造を説明します。"

#: ../../../documentation/301_grammarlanguage.md:17
msgid "### Language Declaration"
msgstr "### 言語宣言"

#: ../../../documentation/301_grammarlanguage.md:19
msgid "Each Xtext grammar starts with a header that defines some properties of the grammar."
msgstr "各Xtext文法は文法の特徴を定義したヘッダーから開始します。"

#: ../../../documentation/301_grammarlanguage.md:21
msgid ""
"```xtext\n"
"grammar org.example.domainmodel.Domainmodel\n"
"        with org.eclipse.xtext.common.Terminals\n"
"```"
msgstr ""
"```xtext\n"
"grammar org.example.domainmodel.Domainmodel\n"
"        with org.eclipse.xtext.common.Terminals\n"
"```"

#: ../../../documentation/301_grammarlanguage.md:26
msgid "The first line declares the name of the language. Xtext leverages Java's class path mechanism. This means that the name can be any valid Java qualifier. The grammar file name needs to correspond to the language name and have the file extension `.xtext`. This means that the name has to be e.g. *Domainmodel.xtext* and must be placed in a package *org.example.domainmodel* on your project's class path. In other words, your `.xtext` file has to reside in a Java source folder to be valid."
msgstr "最初の行は言語の名前を宣言しています。XtextはJavaのクラスパスメカニズムを利用しています。これは、名前にJavaの有効な修飾子を利用できるということを意味しています。文法ファイル名は言語名と拡張子`.xtext`がそれぞれ必要です。例えば、ファイル *Domainmodel.xtext* は、プロジェクトクラスパス内のパッケージ *org.example.domainmodel* に配置されるべきであることを意味しています。言い換えると、`.xtext`ファイルは、Javaソースフォルダとして有効な場所に存在すべきということです。"

#: ../../../documentation/301_grammarlanguage.md:28
msgid "The second aspect that can be deduced from the first line of the grammar is its relationship to other languages. An Xtext grammar can declare another existing grammar to be reused. The mechanism is called [grammar mixin](301_grammarlanguage.html#grammar-mixins)."
msgstr "最初の行から推測できる2つ目の側面は、他の言語との関連です。Xtext文法は既存の文法を再利用するための宣言が可能であり、このメカニズムは [文法ミックスイン](301_grammarlanguage.html#grammar-mixins) と呼ばれています。"

#: ../../../documentation/301_grammarlanguage.md:30
msgid "### EPackage Declarations {#package-declarations}"
msgstr "### EPackage 宣言 {#package-declarations}"

#: ../../../documentation/301_grammarlanguage.md:32
msgid "Xtext parsers create in-memory object graphs while consuming text. Such object-graphs are instances of [EMF](https://www.eclipse.org/modeling/emf/) Ecore models. An Ecore model basically consists of an EPackage containing EClasses, EDataTypes and EEnums (see the [section on EMF](308_emf_integration.html#model-metamodel) for more details) and describes the structure of the instantiated objects. Xtext can infer Ecore models from a grammar (see [Ecore model inference](301_grammarlanguage.html#metamodel-inference)) but it is also possible to import existing Ecore models. You can even mix both approaches and use multiple existing Ecore models and infer some others from a single grammar. This allows for easy reuse of existing abstractions while still having the advantage of short turnarounds with derived Ecore models."
msgstr "Xtextパーサーはテキストからメモリ内オブジェクトグラフを生成します。オブジェクトグラフは [EMF](https://www.eclipse.org/modeling/emf/) Ecoreモデルのインスタンスです。Ecoreモデルは基本的にEPckageに含まれるEClaases、EDataTypesとEEnums (詳細は [EMF節](308_emf_integration.html#model-metamodel)を参照) と、インスタンス化されたオブジェクトの構造を示しています。Xtextは文法([Ecoreモデル推論](301_grammarlanguage.html#metamodel-inference))からEcoreモデルを類推できるが、既存のEcoreモデルをインポートすることも可能です。我々は、複数の既存のEcoreモデルを使用するアプローチと単一文法から他を推論するアプローチの両方をとることができます。これにより、既存の抽象化の再利用を容易にすると同時に、派生したEcoreモデルを用いた短いターンアラウンドの利点を得ることができます。"

#: ../../../documentation/301_grammarlanguage.md:34
msgid "#### EPackage Generation"
msgstr "#### EPackage 生成"

#: ../../../documentation/301_grammarlanguage.md:36
msgid "The easiest way to get started is to let Xtext infer the Ecore model from your grammar. The `generate` declaration in the grammar advises the framework to do so:"
msgstr "最も簡単な開始方法は、あなたの文法からEcoreモデルをXtextに推論させることです。文法中の`生成`宣言はフレームワークに推論するよう通知します。"

#: ../../../documentation/301_grammarlanguage.md:38
msgid ""
"```xtext\n"
"generate domainmodel \"http://www.example.org/domainmodel/Domainmodel\"\n"
"```"
msgstr ""
"```xtext\n"
"generate domainmodel \"http://www.example.org/domainmodel/Domainmodel\"\n"
"```"

#: ../../../documentation/301_grammarlanguage.md:42
msgid "That statement could actually be read as: generate an [EPackage]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EPackage.java) with the *name* `domainmodel` and the *nsURI* `\"http://www.example.org/domainmodel/Domainmodel\"`. Xtext will then add [EClasses]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClass.java) with [EAttributes]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EAttribute.java) and [EReferences]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EReference.java) for the different parser rules in your grammar, as described in [Ecore model inference](301_grammarlanguage.html#metamodel-inference)."
msgstr "この命令文は実際には次のように解釈されます:　*名前* `domainmodel`、*nsURI*  `\"http://www.example.org/domainmodel/Domainmodel\"` で、[EPackage]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EPackage.java)を生成する。Xtextは[Ecore model inference](301_grammarlanguage.html#metamodel-inference)に記述されている文法内の複数のパーサールールに対して、[EClasses]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClass.java)と[EReferences]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EReference.java)を含む[EAttributes]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EAttribute.java)を追加します。"

#: ../../../documentation/301_grammarlanguage.md:44
msgid "#### EPackage Import {#epackage-import}"
msgstr "#### EPackage インポート {#epackage-import}"

#: ../../../documentation/301_grammarlanguage.md:46
msgid "If you already have an existing EPackage, you can import it using its namespace URI:"
msgstr "すでにEPackageを持っている場合、ネームスペースURIを用いることでインポートすることができます:"

#: ../../../documentation/301_grammarlanguage.md:48
msgid ""
"```xtext\n"
"import \"http://www.xtext.org/example/Domainmodel\"\n"
"```"
msgstr ""
"```xtext\n"
"import \"http://www.xtext.org/example/Domainmodel\"\n"
"```"

#: ../../../documentation/301_grammarlanguage.md:52
msgid "A [URI]({{site.src.emf}}/plugins/org.eclipse.emf.common/src/org/eclipse/emf/common/util/URI.java) (Uniform Resource Identifier) provides a simple and extensible means for identifying an abstract or physical resource. It is also possible to import EPackages using resource URIs, but it is strongly recommended to use the namespace URI instead because it is independent from the concrete location in the file system, much more portable across different machines, easier to configure in the workflow, and works better with language mixins. The import via platform URIs or file URIs can be considered deprecated and is only supported for backwards compatibility."
msgstr "[URI]({{site.src.emf}}/plugins/org.eclipse.emf.common/src/org/eclipse/emf/common/util/URI.java) (Uniform Resource Identifier)は、抽象もしくは物理的なリソースを特定するための拡張可能かつシンプルな手段を提供します。リソースURIを用いてEPackageをインポートすることも可能だが、ネームスペースURIを用いることを強く進めます。なぜなら、ネームスペースURIはファイルシステムの具体的な位置から独立しているため、他のマシーンへの移植やワークフローの構築がやりやすく、そして言語のミックスインがよりよく動作します。プラットフォームURIもしくはファイルURI経由のインポートは非推奨とみなされ、下位互換性のためだけにサポートされます。"

#: ../../../documentation/301_grammarlanguage.md:54
msgid "Using package imports usually requires some [adaptations in the generator workflow](302_configuration.html#importing-metamodels)."
msgstr "パッケージインポートは通常、いくらかの[生成ワークフローへの適応](302_configuration.html#importing-metamodels) が必要です。"

#: ../../../documentation/301_grammarlanguage.md:56
msgid "#### Ecore Model Aliases for EPackages"
msgstr "#### EPackageのためのEcoreモデル エイリアス"

#: ../../../documentation/301_grammarlanguage.md:58
msgid "If you want to use multiple EPackages you need to specify aliases in the following way:"
msgstr "もし複数のEPackageを使用するのであれば、次の方法でエイリアスを指定する必要があります:"

#: ../../../documentation/301_grammarlanguage.md:60
msgid ""
"```xtext\n"
"import \"http://www.xtext.org/example/Domainmodel\" as dmodel\n"
"import 'http://www.eclipse.org/anotherPackage' as another\n"
"```"
msgstr ""
"```xtext\n"
"import \"http://www.xtext.org/example/Domainmodel\" as dmodel\n"
"import 'http://www.eclipse.org/anotherPackage' as another\n"
"```"

#: ../../../documentation/301_grammarlanguage.md:65
msgid "When referring to a type somewhere in the grammar you need to qualify the reference using that alias (e.g. `another::SomeType`). Cases where such type references occur are explained below."
msgstr "文法内で型を参照する場合、エイリアスを使って参照を修飾する必要があります。(例`another::SomeType`)以下にこのような型の参照が起こる箇所を説明します。"

#: ../../../documentation/301_grammarlanguage.md:67
msgid "It is also supported to put multiple EPackage imports into one alias. This is no problem as long as there are not any two [EClassifiers]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClassifier.java) with the same name. In that case none of them can be referenced. It is even possible to `import` multiple and `generate` one Ecore model and declare all of them with the same alias. If you do so, for a reference to an [EClassifier]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClassifier.java) first the imported [EPackages]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EPackage.java) are scanned before it is assumed that a type needs to be generated into the inferred package."
msgstr "複数のEPckageインポートを1つのエイリアスに入れることもサポートされています。これは、[EClassifiers]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClassifier.java)に同じ名前のものが2つない限り問題ありません。同じ名前のものが存在する場合、どれも参照できません。複数のEcoreモデルを`import`し、1つのEcoreモデルを`generate`し、そしてそれら全てを同じエイリアスを用いて宣言することも可能です。その場合、[EClassifier]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClassifier.java)を参照するため、最初にインポートされた[EPackages]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EPackage.java)がスキャンされ、その後、推測されたパッケージから型を生成する必要があるとみなされます。"

#: ../../../documentation/301_grammarlanguage.md:69
msgid "Note that using the same alias for multiple EPackages is not recommended, because it might cause problems that are hard to track down. For instance, a reference to `classA` could mistakenly be linked to a newly created EClass instead of an existing EClass `ClassA` because the latter is written with a capital letter."
msgstr "複数のEPackageに対して同じエイリアスをつけることは追跡が困難である問題を引き起こすため非推奨です。例えば、`classA`への参照は既存のEClass `ClassA`が大文字で書かれているため、既存のEClass `ClassA`ではなく、新規に作成したEClassに誤ってリンクされることがあります。"

#: ../../../documentation/301_grammarlanguage.md:71
msgid "### Terminal Rules {#terminal-rules}"
msgstr "### 終端ルール {#terminal-rules}"

#: ../../../documentation/301_grammarlanguage.md:73
msgid "Basically parsing can be separated in the following phases:"
msgstr "基本的に、パースは以下のフェーズに分割することができます:"

#: ../../../documentation/301_grammarlanguage.md:75
msgid ""
"1.  Lexing\n"
"1.  Parsing\n"
"1.  Linking\n"
"1.  Validation"
msgstr ""
"1.  字句解析\n"
"1.  パース\n"
"1.  リンク\n"
"1.  検証"

#: ../../../documentation/301_grammarlanguage.md:80
msgid "In the first stage called *lexing*, a sequence of characters (the text input) is transformed into a sequence of so-called *tokens*. In this context, a token is a sort of a strongly typed part or region of the input sequence. It consists of one or more characters and is matched by a particular terminal rule or keyword and therefore represents an atomic symbol. Terminal rules are also referred to as *token rules* or *lexer rules*. There is an informal naming convention that names of terminal rules are all upper-case."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:82
msgid "In the [domainmodel tutorial](102_domainmodelwalkthrough.html) there are no explicitly defined terminal rules, since it only uses the *ID* rule which is inherited from the grammar `org.eclipse.xtext.common.Terminals` (see [Common Terminals](#common-terminals)). Therein the *ID* rule is defined as follows:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:84
msgid ""
"```xtext\n"
"terminal ID: \n"
"    ('^')?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:89
msgid "It says that a token *ID* starts with an optional `'^'` character (caret), followed by a letter `('a'..'z'|'A'..'Z')` or underscore `'_'` followed by any number of letters, underscores and numbers `('0'..'9')`."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:91
msgid "The caret is used to escape an identifier if there are conflicts with existing keywords. It is removed by the *ID* rule's [ValueConverter](303_runtime_concepts.html#value-converter)."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:93
msgid "This is the simplified formal definition of terminal rules:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:95
msgid ""
"```xtext\n"
"TerminalRule:\n"
"    'terminal' name=ID ('returns' type=TypeRef)? ':'\n"
"    alternatives=TerminalAlternatives ';';\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:101
msgid "Note that *the order of the terminal rules is crucial for your grammar*, as they may shadow each other. This is especially important for newly introduced rules in connection with imported rules from used grammars."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:103
msgid "It's almost in any case recommended to use [data type rules](#datatype-rules) instead. Let's assume you want to add a rule to allow fully qualified names in addition to simple IDs. Since a qualified name with only one segment looks like a plain ID, you should implement it as a data type rule instead of adding another terminal rule. The same rule of thumb applies to floating point literals, too."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:105
msgid "#### Return Types"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:107
msgid "Each terminal rule returns an atomic value (an [EDataType]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EDataType.java)). By default, it's assumed that an instance of `ecore::EString` should be returned. However, if you want to provide a different type you can specify it. For instance, the rule *INT* is defined as:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:109
msgid ""
"```xtext\n"
"import \"http://www.eclipse.org/emf/2002/Ecore\" as ecore\n"
"//...\n"
"terminal INT returns ecore::EInt:\n"
"    ('0'..'9')+;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:116
msgid "This means that the terminal rule *INT* returns instances of `ecore::EInt`. It is possible to define any kind of data type here, which just needs to be an instance of `ecore::EDataType`. In order to tell the framework how to convert the parsed string to a value of the declared data type, you need to provide your own implementation of the [IValueConverterService]({{site.src.xtext_core}}/org.eclipse.xtext/src/org/eclipse/xtext/conversion/IValueConverterService.java) (see [Value Converter](303_runtime_concepts.html#value-converter)). The value converter is also the service that allows to remove escape sequences or semantically unnecessary characters such as quotes from string literals or the caret symbol `'^'` from the identifiers."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:118 ../../../documentation/301_grammarlanguage.md:239
msgid "#### Extended Backus-Naur Form Expressions"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:120
msgid "Terminal rules are described using *Extended Backus-Naur Form*-like (EBNF) expressions. The different expressions are described in the following. Each of these expressions allows to define a cardinality. There are four different possible cardinalities:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:122
msgid ""
"1.  exactly one (the default, no operator)\n"
"1.  zero or one (operator `?`)\n"
"1.  zero or more (operator `*`)\n"
"1.  one or more (operator `+`)"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:127
msgid "##### Keywords / Characters {#keywords}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:129
msgid "Keywords are a kind of terminal rule literals. The *ID* rule in `org.eclipse.xtext.common.Terminals` for instance starts with a keyword:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:131
msgid ""
"```xtext\n"
"terminal ID:\n"
"    '^'? ... ;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:136
msgid "The question mark sets the cardinality to *zero or one* (i.e. optional) as explained above."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:138
msgid ""
"A keyword can have any length, e.g. `'entity'`, and contain arbitrary characters. The following standard Java notations for special characters are allowed: `\n"
"`, `
`, `\t`, `\\b`, `\\f` and the quoted unicode character notation, such as `\\u123`."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:140
msgid "##### Character Ranges"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:142
msgid "A character range can be declared using the `..` operator. Example:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:144
msgid ""
"```xtext\n"
"terminal INT returns ecore::EInt:\n"
"    ('0'..'9')+;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:149
msgid "In this case an *INT* is comprised of one or more (note the `+` operator) characters between (and including) `'0'` and `'9'`."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:151
msgid "##### Wildcard"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:153
msgid "If you want to allow any character you can simply write the wildcard operator `.` (dot). Example:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:155
msgid ""
"```xtext\n"
"terminal FOO:\n"
"    'f' . 'o';\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:160
msgid "The rule above would allow expressions like `foo`, `f0o` or even `f°o`."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:162
msgid "##### Until Token"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:164
msgid "With the *until token* it is possible to state that everything should be consumed until a certain token occurs. The multi-line comment is implemented this way:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:166
msgid ""
"```xtext\n"
"terminal ML_COMMENT:\n"
"    '/*' -> '*/';\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:171
msgid "This is the rule for Java-style comments that begin with `/*` and end with `*/`."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:173
msgid "##### Negated Token {#negated-tokens}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:175
msgid "All the tokens explained above can be inverted using a preceding exclamation mark:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:177
msgid ""
"```xtext\n"
"terminal BETWEEN_HASHES:\n"
"    '#' (!'#')* '#';\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:182
msgid "##### Rule Calls {#rule-calls}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:184
msgid "Rules can refer to other rules. This is simply done by using the name of the rule to be called. We refer to this as *rule calls*. Rule calls in terminal rules can only point to terminal rules. Example:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:186
msgid ""
"```xtext\n"
"terminal DOUBLE:\n"
"    INT '.' INT;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:191
msgid "Note: It is generally not a good idea to implement floating point literals with terminal rules. You should use [data type rules](#datatype-rules) instead due to possible shadowing problems explained above."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:193
msgid "##### Alternatives {#alternatives}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:195
msgid "Alternatives allow to define multiple valid options in the input file. For instance, the white space rule uses alternatives like this:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:197
msgid ""
"```xtext\n"
"terminal WS:\n"
"    (' '|'\t'|'
'|'\n"
"')+;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:202
msgid ""
"That is a WS can be made of one or more white space characters (including `' ', '\t', '
', '\n"
"'`)."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:204
msgid "##### Groups {#groups}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:206
msgid "Finally, if you put tokens one after another, the whole sequence is referred to as a group. Example:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:208
msgid ""
"```xtext\n"
"terminal ASCII:\n"
"    '0x' ('0'..'7') ('0'..'9'|'A'..'F');\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:213
msgid "This group has three elements `'0x'`, `('0'..'7')`, and `('0'..'9'|'A'..'F')`, which have to appear in this order."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:215
msgid "#### Terminal Fragments {#terminal-fragment}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:217
msgid "Since terminal rules are used in a stateless context, it's not easily possible to reuse parts of their definition. Fragments solve this problem. They allow the same EBNF elements as terminal rules do but may not be consumed by the lexer. Instead, they have to be used by other terminal rules. This allows to extract repeating parts of a definition:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:219
msgid ""
"```xtext\n"
"terminal fragment ESCAPED_CHAR:\n"
"    '\\\\' ('n'|'t'|'r'|'\\\\');\n"
"terminal STRING: \n"
"    '\"' ( ESCAPED_CHAR | !('\\\\'|'\"') )* '\"' |\n"
"    \"'\" ( ESCAPED_CHAR | !('\\\\'|\"'\") )* \"'\";\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:227
msgid "#### EOF &ndash; End Of File {#eof}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:229
msgid "The `EOF` (End Of File) token may be used to describe that the end of the input stream is a valid situation at a certain point in a terminal rule. This allows to consume the complete remaining input of a file starting with a special delimiter."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:231
msgid "`terminal UNCLOSED_STRING : '\"' (!'\"')* EOF;`"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:233
msgid "The `EOF` token cannot be [negated](301_grammarlanguage.html#negated-tokens)."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:235
msgid "### Parser Rules {#parser-rules}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:237
msgid "The parser is fed with a sequence of terminals and walks through the so-called *parser rules*. Hence a parser rule &ndash; contrary to a terminal rule &ndash; does not produce a single atomic terminal token, but a tree of non-terminal and terminal tokens. They lead to a so-called *parse tree* (in Xtext it is also referred as *node model*). Furthermore, parser rules are handled as kind of a building plan for the creation of the [EObjects]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java) that form the semantic model (the linked *abstract syntax tree* or AST). Due to this fact, parser rules are also called production or EObject rules. Different constructs like actions and assignments are used to derive types and initialize the semantic objects accordingly."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:241
msgid "Not all the expressions that are available in terminal rules can be used in parser rules. Character ranges, wildcards, the until token and the negation as well as the EOF token are only available for terminal rules."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:243
msgid "The elements that are available in parser rules as well as in terminal rules are"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:245
msgid ""
"1.  [Groups](301_grammarlanguage.html#groups)\n"
"1.  [Alternatives](301_grammarlanguage.html#alternatives)\n"
"1.  [Keywords](301_grammarlanguage.html#keywords)\n"
"1.  [Rule Calls](301_grammarlanguage.html#rule-calls)"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:250
msgid "In addition to these elements, there are some expressions used to direct how the AST is constructed. They are listed and explained in the following."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:252
msgid "##### Assignments {#assignments}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:254
msgid "Assignments are used to assign the consumed information to a feature of the currently produced object. The type of the current object, its [EClass]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClass.java), is specified by the return type of the parser rule. If it is not explicitly stated it is implied that the type's name equals the rule's name. The type of the assigned feature is inferred from the right hand side of the assignment."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:256 ../../../documentation/301_grammarlanguage.md:393
msgid "Example:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:258
msgid ""
"```xtext\n"
"DataType:\n"
"    'datatype' name = ID;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:263
msgid "The syntactic declaration for datatypes starts with a keyword `datatype` followed by an assignment: `name = ID`. The left hand side refers to a feature *name* of the current object (which has the EClass *DataType* in this case). The right hand side can be a rule call, a keyword, a [cross-reference](301_grammarlanguage.html#cross-references) or an alternative comprised by the former options. The type of the feature needs to be compatible with the type of the expression on the right. As *ID* returns an [EString]({{site.javadoc.java}}/java/lang/String.html) in this case, the feature *name* needs to be of type EString as well."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:265
msgid "There are three different assignment operators, each with different semantics."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:267
msgid ""
"1.  The simple equal sign `=` is the straightforward assignment, and is used for features which take only one element.\n"
"1.  The `+=` sign (the add operator) expects a multi-valued feature and adds the value on the right hand side to that feature, which is a list feature.\n"
"1.  The `?=` sign (boolean assignment operator) expects a feature of type [EBoolean]({{site.javadoc.java}}/java/lang/Boolean.html) and sets it to true if the right hand side was consumed, independently from the concrete value of the right hand side."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:271
msgid "The used assignment operator does not influence the cardinality of the expected symbols on the right hand side."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:273
msgid "##### Cross-References {#cross-references}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:275
msgid "A unique feature of Xtext is the ability to declare cross-references in the grammar. In traditional compiler construction such cross-references are not established during parsing but in a later linking phase. This is the same in Xtext, but we allow to specify cross-reference information in the grammar. This information is used by the [linker](303_runtime_concepts.html#linking)."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:277
msgid "The syntax for cross-references is:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:279
msgid ""
"```xtext\n"
"CrossReference:\n"
"    '[' type=TypeRef ('|' ^terminal=CrossReferenceableTerminal )? ']';\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:284
msgid "For example, Features in the [domainmodel tutorial](102_domainmodelwalkthrough.html) contain a cross-reference pointing to a Type:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:286
msgid ""
"```xtext\n"
"Feature:\n"
"    (many ?= 'many')? name = ID ':' type = [Type];\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:291
msgid "It is important to understand that the text between the square brackets does not refer to another rule, but to an [EClass]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClass.java) &ndash; which is a type and not a parser rule. This can be sometimes confusing because one usually uses the same name for the rules and for the returned types."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:293
msgid "Looking at the syntax definition for cross-references, there is an optional part starting with a vertical bar (pipe) followed by *CrossReferenceableTerminal*. This is the part describing the concrete text from which the cross-reference should be established. If the terminal is omitted, it is expected to be the rule with the name *ID* &ndash; if one can be found. The terminal is mandatory for languages that do not define a rule with the name *ID*."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:295
msgid "##### Unordered Groups {#unordered-groups}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:297
msgid "The elements of an unordered group can occur in any order, but each element must appear once. Members of unordered groups are separated by `&`. The following rule `Modifier` allows to parse simplified modifiers of the Java language:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:299
msgid ""
"```xtext\n"
"Modifier: \n"
"    static?='static'? & final?='final'? & visibility=Visibility;"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:303
msgid ""
"enum Visibility:\n"
"    PUBLIC='public' | PRIVATE='private' | PROTECTED='protected';\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:307
msgid "With these definitions the following sequences of tokens are valid:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:309
msgid ""
"```java\n"
"public static final\n"
"static protected \n"
"final private static\n"
"public\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:316
msgid "In contrast, the parser refuses to accept these input lines:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:318
msgid ""
"```java\n"
"static final static // ERROR: static appears twice\n"
"public static final private // ERROR: visibility appears twice\n"
"final // ERROR: visibility is missing\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:324
msgid "Note that if you want an element of an unordered group to appear once or not at all, you have to choose a cardinality of `?`. In the example, the visibility is mandatory, while `static` or `final` are optional. Elements with a cardinality of `*` or `+` have to appear continuously without interruption, i.e."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:326
msgid ""
"```xtext\n"
"ExampleRule:\n"
"    values+=INT* & name=ID;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:331
msgid "can parse these lines"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:333
msgid ""
"```java\n"
"0 8 15 x\n"
"x 0 8 15 \n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:338
msgid "but does not consume the following sequence without raising an error"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:340
msgid ""
"```java\n"
"0 x 8 15 // wrong, as values must not be interrupted by a name (ID)\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:344
msgid "##### Simple Actions"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:346
msgid "The object to be returned by a parser rule is usually created lazily on the first assignment. Its type is determined from the specified return type of the rule, which may have been inferred from the rule's name if no explicit return type is specified."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:348
msgid "With Actions however, the creation of returned [EObject]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java) can be made explicit. Xtext supports two kinds of Actions:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:350
msgid ""
"1. *Simple* Actions\n"
"1. *Assigned* Actions"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:353
msgid "If you want to enforce the creation of an instance with specific type you can use simple actions. In the following example *TypeB* must be a subtype of *TypeA*. An expression `A ident` should create an instance of *TypeA*, whereas `B ident` should instantiate *TypeB*."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:355
msgid "If you don't use actions, you'll have to define an alternative and delegate rules to guide the parser to the right types for the to-be-instantiated objects:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:357
msgid ""
"```xtext\n"
"MyRule returns TypeA:\n"
"    \"A\" name=ID |\n"
"    MyOtherRule;"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:362
msgid ""
"MyOtherRule returns TypeB:\n"
"    \"B\" name = ID;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:366
msgid "Actions however allow to make this explicit. Thereby they can improve the readability of grammars."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:368
msgid ""
"```xtext\n"
"MyRule returns TypeA:\n"
"    \"A\" name=ID |\n"
"    \"B\" {TypeB} name=ID; \n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:374
msgid "Generally speaking, the instance is created as soon as the parser hits the first assignment. However, actions allow to explicitly instantiate any [EObject]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java). The notation `{TypeB}` will create an instance of *TypeB* and assign it to the result of the parser rule. This allows to define parser rules without any assignment and to create objects without the need to introduce unnecessary delegate rules."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:376
msgid "Note: If a parser rule does not instantiate any object because it does not contain an Action and no mandatory Assignment, you'll likely end up with unexpected situations for valid input files. Xtext detects this situation and will raise a warning (with a corresponding quickfix) for the parser rules in question."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:378
msgid "##### Unassigned Rule Calls"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:380
msgid "We previously explained that the [EObject]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java) to be returned is created lazily when the first assignment occurs or as soon as a simple action is evaluated. There is another concept to find the EObject to be returned, called *unassigned rule call*. Unassigned rule calls, as the name suggests it, are rule calls to other parser rules which are not used within an assignment. The return value of the called rule becomes the return value of the calling parser rule if it is not assigned to a feature."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:382
msgid "With unassigned rule calls one can, for instance, create rules which just dispatch to other rules:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:384
msgid ""
"```xtext\n"
"AbstractToken:\n"
"    TokenA |\n"
"    TokenB |\n"
"    TokenC;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:391
msgid "As `AbstractToken` could possibly return an instance of *TokenA*, *TokenB* or *TokenC*. Its type must be a super type for all these types. Since the return value of the called rule becomes the result of the current rule, it is possible to further change the state of the AST element by assigning additional features."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:395
msgid ""
"```xtext\n"
"AbstractToken:\n"
"    ( TokenA |\n"
"      TokenB |\n"
"      TokenC ) cardinality=('?'|'+'|'*')?;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:402
msgid "This way the *cardinality* is optional (last question mark) and can be represented by a question mark, a plus, or an asterisk. It will be assigned to either an instance of type *TokenA*, *TokenB*, or *TokenC*, which are all subtypes of *AbstractToken*. The rule in this example will never create an instance of *AbstractToken* directly, but always return the instance that has been created by the invoked *TokenX* rule."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:404
msgid "##### Assigned Actions {#grammar-actions}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:406
msgid "Xtext leverages the powerful ANTLR parser which implements an `LL(*)` algorithm. Even though LL parsers have many advantages with respect to readability, debuggability and error recovery, there are also some drawbacks. The most important one is that it does not allow left recursive grammars. For instance, the following rule is not allowed in LL-based grammars, because `Expression '+' Expression` is left-recursive:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:408
msgid ""
"```xtext\n"
"Expression:\n"
"    Expression '+' Expression |\n"
"    '(' Expression ')' |\n"
"    INT;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:415
msgid "Instead one has to rewrite such left-recursive rules by \"left-factoring\" them:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:417
msgid ""
"```xtext\n"
"Expression:\n"
"    TerminalExpression ('+' TerminalExpression)*;"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:421
msgid ""
"TerminalExpression:\n"
"    '(' Expression ')' |\n"
"    INT;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:426
msgid "In practice this is always the same pattern and therefore not too difficult. However, by simply applying the Xtext AST construction features we've covered so far, a grammar such as"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:428
msgid ""
"```xtext\n"
"Expression:\n"
"    {Operation} left=TerminalExpression (ops+='+' rights+=TerminalExpression)*"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:432 ../../../documentation/301_grammarlanguage.md:456
msgid ""
"TerminalExpression returns Expression:\n"
"    '(' Expression ')' |\n"
"    {IntLiteral} value=INT;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:437
msgid "would result in unwanted elements in the AST. For instance the expression `(42)` would result in a tree like this:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:439
msgid ""
"```mwe2\n"
"Operation {\n"
"  left=Operation {\n"
"    left=IntLiteral {\n"
"      value=42\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:449
msgid "Typically one would only want to have one instance of *IntLiteral* instead. This problem can be solved by using a combination of unassigned rule calls and assigned actions:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:451
msgid ""
"```xtext\n"
"Expression:\n"
"    TerminalExpression ({Operation.left=current} \n"
"    op='+' right=TerminalExpression)*"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:461
msgid "In the example above `{Operation.left=current}` is a so-called *tree rewrite action*, which creates a new instance of the stated [EClass]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClass.java) *Operation* and assigns the element currently to-be-returned (the `current` variable) to a feature of the newly created object. The example uses the feature *left* of the *Operation* instance to store the previously returned *Expression*. In Java these semantics could be expressed as:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:463
msgid ""
"```java\n"
"Operation temp = new Operation();\n"
"temp.setLeft(current);\n"
"current = temp;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:469
msgid "With these improved rules the expression `(42)` would lead to a single *IntLiteral* instance, while `40 + 2` creates an *Operation* with two *IntLiterals*."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:471
msgid "#### Syntactic Predicates {#syntactic-predicates}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:473
msgid "It is sometimes not easily possible to define an `LL(*)` grammar for a given language that parses all possible valid input files and still produces abstract syntax graphs that mimic the actual structure of the files. There are even cases that cannot be described with an unambiguous grammar. There are solutions that allow to deal with this problem:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:475
msgid ""
"* Enable backtracking: Xtext allows to enable backtracking for the ANTLR parser generator. This is usually not recommended since it influences error message strategies at runtime and shadows actually existing problems in the grammar.\n"
"* Syntactic predicates: The grammar language allows to guide the parser in case of ambiguities. This mechanism is achieved by *syntactic predicates*. Since they affect only a very small part of the grammar, syntactic predicates are the recommended approach to handle ANTLR error messages during the parser generation."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:478
msgid "The classical example for ambiguous language parts is the *dangling else problem*. A conditional in a programming language usually looks like this:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:480
msgid ""
"```java\n"
"if (isTrue())\n"
"    doStuff();\n"
"else \n"
"    dontDoStuff();\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:487
msgid "The problems becomes obvious as soon as nested conditions are used:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:489
msgid ""
"```java\n"
"if (isTrue())\n"
"    if (isTrueAsWell())\n"
"        doStuff();\n"
"    else \n"
"        dontDoStuff();\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:497
msgid "Where does the `else` branch belong to? This question can be answered by a quick look into the language specification which tells that the `else` branch is part of the inner condition. However, the parser generator cannot be convinced that easily. We have to guide it to this decision point by means of syntactic predicates which are expressed by a leading `=>` operator."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:499
msgid ""
"```xtext\n"
"Condition: \n"
"    'if' '(' condition=BooleanExpression ')'\n"
"    then=Expression \n"
"    (=>'else' else=Expression)?\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:506
msgid "The parser understands the predicate basically like this: If you are at this particular decision point and you don't know what to do, check whether the `else` keyword is present. If it is, take that branch directly without considering other options that would match the same token sequence."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:508
msgid "Well chosen predicates allow to solve most ambiguities and backtracking can often be disabled. Be warned, though, that an ambiguity for the parser can also mean an ambiguity for the user, so before forcing the syntax into handling such cases you should consider avoiding them in the first place."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:510
msgid "##### First Token Set Predicates"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:512
msgid "Sometimes you need to put a syntactic predicate on a more complex rule, e.g. an expression, which might be very long. For disambiguation it is often sufficient to look only at the first token set. In those cases one can use the `->` operator instead of `=>`, instructing the parser to just look at the first token and make the decision based on that. This can heavily reduce the lookahead and as a consequence make the parser faster and more robust to syntactic errors. This also affects the behavior of the IDE, such as content assist, in a positive way."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:514
msgid "### Hidden Terminal Symbols {#hidden-terminals}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:516
msgid "Because parser rules describe not a single token, but a sequence of patterns in the input, it is necessary to define the important parts of the input. Xtext introduces the concept of hidden tokens to handle semantically irrelevant things like white spaces, comments, etc. in the input sequence gracefully. It is possible to define a set of terminal symbols that are hidden from the parser rules and automatically skipped when they are recognized. Nevertheless, they are transparently woven into the node model, but not relevant for the semantic model."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:518
msgid "Hidden terminals may optionally appear between any other terminals in any cardinality. They can be described per rule or for the whole grammar. When [reusing a single grammar](301_grammarlanguage.html#grammar-mixins) its definition of hidden tokens is reused, too. The grammar `org.eclipse.xtext.common.Terminals` comes with a reasonable default and hides all comments and white spaces from the parser rules."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:520
msgid "If a rule defines hidden symbols, you can think of a kind of scope that is automatically introduced. Any rule that is called transitively by the declaring rule uses the same hidden terminals as the calling rule, unless it defines hidden tokens itself."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:522
msgid ""
"```xtext\n"
"Person hidden(WS, ML_COMMENT, SL_COMMENT):\n"
"    name=Fullname age=INT ';';"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:526
msgid ""
"Fullname:\n"
"    (firstname=ID)? lastname=ID;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:530
msgid "The sample rule *Person* defines multiline comments (`ML_COMMENT`), single-line comments (`SL_COMMENT`), and white space (`WS`) to be allowed between the *name* and the *age*. Because the rule *Fullname* does not introduce an own set of hidden terminals, it allows the same symbols to appear between *firstname* and *lastname* as the calling rule *Person*. Thus, the following input is perfectly valid for the given grammar snippet:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:532
msgid ""
"```java\n"
"John /* comment */ Smith // line comment\n"
"/* comment */\n"
"      42      ; // line comment\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:538
msgid "A list of all default terminals such as `WS` can be found in [Common Terminals](#common-terminals)."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:540
msgid "### Data Type Rules {#datatype-rules}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:542
msgid "Data type rules create instances of [EDataType]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EDataType.java) instead of [EClass]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClass.java). They are quite similar to terminal rules, but they are actually parser rules and are therefore"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:544
msgid ""
"1. context sensitive and\n"
"1. allow to use of hidden tokens."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:547
msgid "Assuming you want to define a rule to consume Java-like qualified names (e.g. `foo.bar.Baz`) you could write:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:549
msgid ""
"```xtext\n"
"QualifiedName:\n"
"    ID ('.' ID)*;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:554
msgid "In contrast to a terminal rule this is only valid in certain contexts, i.e. it won't conflict with the rule *ID*. If you had defined it as a terminal rule, it would possibly hide the simple *ID* rule."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:556
msgid "In addition, by defining the *QualifiedName* as a data type rule, it is allowed to use hidden tokens such as `/* comment */` between the segment IDs and dots (e.g. `foo/* comment */. bar . Baz`)."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:558
msgid "Return types can be specified in the same way as for terminal rules:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:560
msgid ""
"```xtext\n"
"QualifiedName returns ecore::EString:\n"
"    ID ('.' ID)*;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:565
msgid "Note that rules that do not call other parser rules and do neither contain any actions nor [assignments](301_grammarlanguage.html#assignments) are considered to be data type rules, and the data type [EString]({{site.javadoc.java}}/java/lang/String.html) is implied if none has been explicitly declared."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:567
msgid "[Value converters](303_runtime_concepts.html#value-converter) are used to transform the parsed string to the actually returned data type value."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:569
msgid "### Enum Rules"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:571
msgid "Enum rules return enumeration literals from strings. They can be seen as a shortcut for data type rules with specific value converters. The main advantage of enum rules is their simplicity, type safety and therefore nice validation. Furthermore it is possible to infer enums and their respective literals during the Ecore model transformation."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:573
msgid "If you want to define a `ChangeKind` from [org.eclipse.emf.ecore.change/model/Change.ecore](https://github.com/eclipse/emf/blob/master/plugins/org.eclipse.emf.ecore.change/model/Change.ecore) with *ADD*, *MOVE* and *REMOVE* you could write:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:575
msgid ""
"```xtext\n"
"enum ChangeKind:\n"
"    ADD | MOVE | REMOVE;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:580
msgid "It is even possible to use alternative literals for your enums or reference an enum value twice:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:582
msgid ""
"```xtext\n"
"enum ChangeKind:\n"
"    ADD = 'add' | ADD = '+' | \n"
"    MOVE = 'move' | MOVE = '->' | \n"
"    REMOVE = 'remove' | REMOVE = '-';\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:589
msgid "Please note that Ecore does not support unset values for enums. If you define a grammar like"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:591
msgid ""
"```xtext\n"
"Element:\n"
"\t'element' name=ID (value=SomeEnum)?;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:596
msgid "with the input of `element Foo` the resulting instance *Foo* will hold the enum value with the internal representation of `0` (zero). When generating the EPackage from your grammar this will be the first literal you define. As a workaround you could introduce a dedicated none-value or order the enums accordingly. Note that it is not possible to define an enum literal with an empty textual representation. You can overcome this by importing a meta model where the enum is defined and omitting some of its literals in the grammar."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:598
msgid ""
"### Grammar Annotations {#grammar-annotations}\n"
"Parser Rules can be annotated with several useful annotations. In the following sections there is an overview. Please keep in mind that those annotations will only work on Parser Rules. You'll get an error if you try to use them on Terminal or Enum Rules."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:601
msgid ""
"#### Override\n"
"Sometimes you want to override an existing Parser Rule of a given super grammar to customize it. To do that, you have to create a rule with the same name. It's clear for you that this is a customization, but for the reader of the grammar it's not. To make that more explicit `@Override` marks a rule as being a customization of an already existing rule in a super grammar. You'll get a warning if a rule is a customization and is not marked as Override and an error if it's not an customization and therefore must not be marked as Override.\n"
"#### Final\n"
"Overriding Parser Rules is a common thing but if you want to make sure that nobody overrides a special rule the `@Final` annotation gives support for that.\n"
"#### Deprecated\n"
"Language evolution is an important part of building serious DSLs. Adding something to a grammar is easy as long as the old instances of the grammar are still valid to the new grammar. It becomes hard if you want to remove something and you have to be very careful. Marking classes as deprecated is a good indicator for users to switch to the new API. With `@Deprecated` Xtext has support to mark Parser Rules to be deprecated. \n"
"This will generate validations and the possibility to change the severity through preferences. As a default users will get a warning when using these rules. Of course it's up to you to decide what the severity should be - this opens the possibility to safely remove parts of the grammar by informing in advance with a warning and raise the severity to error afterwards."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:609
msgid ""
"#### Exported\n"
"As a default all elements that have a name that are exposed through the index to be referenced from outside. As a start this might fit your needs, but sooner or later you might run out of memory (big index) or you simply want to hide elements from the outside world. To do that you can write a custom version of the [IDefaultResourceDescriptionStrategy]({{site.src.xtext_core}}/org.eclipse.xtext/src/org/eclipse/xtext/resource/IDefaultResourceDescriptionStrategy.java) or simply use the `@Exported` annotation. This will generate a custom strategy as soon as there is at least one `@Exported` annotation in your grammar."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:612 ../../../documentation/301_grammarlanguage.md:688 ../../../documentation/301_grammarlanguage.md:767
msgid "---"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:614
msgid "## Ecore Model Inference {#metamodel-inference}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:616
msgid "The Ecore model (or meta-model) of a textual language describes the structure of its abstract syntax trees (AST)."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:618
msgid "Xtext uses Ecore's EPackages to define Ecore models. Ecore models are declared to be either inferred from the grammar or imported. By using the `generate` directive, one tells Xtext to infer an EPackage from the grammar."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:620
msgid "### Type and Package Generation"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:622
msgid "Xtext creates"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:624
msgid ""
"* an [EPackage]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EPackage.java)\n"
"  * for each `generate` declaration. The *name* of the EPackage is set to the first parameter of such a declaration, its *nsURI* to the second parameter. An optional alias as the third parameter allows to distinguish the generated EPackages later. Only one generated package declaration per alias is allowed.\n"
"* an [EClass]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClass.java)\n"
"  * for each return type of a parser rule. If a parser rule does not define a return type, an implicit one with the same name as the rule itself is assumed. You can specify multiple rules that return the same type, but only one EClass is generated for each type name.\n"
"  * for each type defined in an action or a cross-reference.\n"
"* an [EEnum]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EEnum.java)\n"
"  * for each return type of an enum rule.\n"
"* an [EDataType]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EDataType.java)\n"
"  * for each return type of a terminal rule or a data type rule."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:634
msgid "All EClasses, EEnums, and EDataTypes are added to the EPackage referred to by the alias provided in the type reference they were created from."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:636
msgid "### Feature and Type Hierarchy Generation"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:638
msgid "While walking through the grammar, the model inference algorithm keeps track of a set of the currently possible return types to add features to."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:640
msgid ""
"* Entering a parser rule the set contains only the return type of the rule. \n"
"* Entering an element of an alternative the set is reset to the same state it was in when entering the first option of the alternative.\n"
"* Leaving an alternative the set contains the union of all types at the end of each of its paths.\n"
"* After an optional element, the set is reset to the same state it was before entering it.\n"
"* After a non-optional unassigned rule call the set contains only the return type of the called rule. An optional rule call does not modify the set. A rule call is optional if its cardinality is `?` or `*`.\n"
"* After an action the set contains only the type of the action."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:647
msgid "While traversing the parser rules Xtext creates"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:649
msgid ""
"* an [EAttribute]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EAttribute.java) in each current return type\n"
"  * of type [EBoolean]({{site.javadoc.java}}/java/lang/Boolean.html) for each feature assignment using the `?=` operator. No further EReferences or EAttributes are generated from such an assignment.\n"
"  * for each assignment with the `=` or `+=` operator calling a terminal rule or data type rule. Its type is the return type of the called rule.\n"
"* an [EReference]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EReference.java) in each current return type\n"
"  * for each assignment with the `=` or `+=` operator in a parser rule calling a parser rule. The type of the EReference is the return type of the called parser rule.\n"
"  * for each assigned action. The type of the reference is the return type of the current rule containing the action."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:656
msgid "Each [EAttribute]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EAttribute.java) or [EReference]({{site.src.emf}}/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EReference.java) takes its name from the assignment or action that caused it. Multiplicities are `0..1` for assignments with the `=` operator and `0..*` for assignments with the `+=` operator."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:658
msgid "Furthermore, each type that is added to the currently possible return types automatically extends the current return type of the parser rule. You can specify additional common super types by means of \"artificial\" parser rules that are never called, e.g."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:660
msgid ""
"```xtext\n"
"CommonSuperType:\n"
"    SubTypeA | SubTypeB | SubTypeC;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:665
msgid "After the traversal of all grammar rules the model inference algorithm examines all generated EClasses and lifts up similar features to supertypes if there is more than one subtype and the feature is defined in all subtypes. This works even for multiple super types."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:667
msgid "### Enum Literal Generation"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:669
msgid "For each alternative defined in an enum rule, the transformer creates an enum literal, as long as no other literal with the same name can be found. The *literal* property of the generated enum literal is set to the right hand side of the declaration. If it is omitted, an enum literal with equal *name* and *literal* attributes is inferred."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:671
msgid ""
"```xtext\n"
"enum MyGeneratedEnum:\n"
"    NAME = 'literal' | EQUAL_NAME_AND_LITERAL;\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:676
msgid "### Error Conditions"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:678
msgid "The following conditions cause an error"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:680
msgid ""
"*   An EAttribute or EReference has two different types or different cardinalities.\n"
"*   There is an EAttribute and an EReference with the same name in the same EClass.\n"
"*   There is a cycle in the type hierarchy.\n"
"*   A new EAttribute, EReference or super type is added to an imported type.\n"
"*   An EClass is added to an imported EPackage.\n"
"*   An undeclared alias is used.\n"
"*   An imported Ecore model cannot be loaded."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:690
msgid "## Grammar Mixins {#grammar-mixins}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:692
msgid "Xtext supports the reuse of existing grammars. Grammars that are created via the Xtext wizard use `org.eclipse.xtext.common.Terminals` by default, which introduces a common set of terminal rules and defines reasonable defaults for hidden terminals."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:694
msgid ""
"```xtext\n"
"grammar org.example.domainmodel.Domainmodel\n"
"    with org.eclipse.xtext.common.Terminals"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:698
msgid "generate domainmodel \"http://www.example.org/domainmodel/Domainmodel\""
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:700
msgid ""
"Model:\n"
"    greetings+=Greeting*;"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:703
msgid ""
"Greeting:\n"
"    'Hello' name=ID '!';\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:707
msgid "To reuse an existing grammar, make sure the grammar file is on the classpath of the inheriting language. If it is in a different plug-in, make sure to add a plug-in dependency in the `MANIFEST.MF`."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:709
msgid "Mixing another grammar into a language makes the rules defined in that grammar referable. It is also possible to overwrite rules from the used grammar. Example:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:711
msgid ""
"```xtext\n"
"grammar my.SuperGrammar"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:714
msgid "generate super \"http://my.org/super\""
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:716
msgid ""
"RuleA: 'a' stuff=RuleB;\n"
"RuleB: '{' name=ID '}';\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:720
msgid ""
"```xtext\n"
"grammar my.SubGrammar with my.SuperGrammar"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:723
msgid "import \"http://my.org/super\""
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:725
msgid "Model: (ruleAs+=RuleA)*;"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:727
msgid ""
"// overrides my.SuperGrammar.RuleB\n"
"@Override\n"
"RuleB: '[' name=ID ']';\n"
"```"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:732
msgid "Declared terminal rules always get a higher priority than imported terminal rules."
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:734
msgid "### Common Terminals {#common-terminals}"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:736
msgid "Xtext ships with a default set of predefined, reasonable and often required terminal rules. The grammar for these common terminal rules is defined as follows:"
msgstr ""

#: ../../../documentation/301_grammarlanguage.md:738
msgid ""
"```xtext\n"
"grammar org.eclipse.xtext.common.Terminals\n"
"    hidden(WS, ML_COMMENT, SL_COMMENT)"
msgstr ""
"```xtext\n"
"grammar org.eclipse.xtext.common.Terminals\n"
"    hidden(WS, ML_COMMENT, SL_COMMENT)"

#: ../../../documentation/301_grammarlanguage.md:742
msgid "import \"http://www.eclipse.org/emf/2002/Ecore\" as ecore"
msgstr "import \"http://www.eclipse.org/emf/2002/Ecore\" as ecore"

#: ../../../documentation/301_grammarlanguage.md:744
msgid ""
"terminal ID:\n"
"    '^'?('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;"
msgstr ""
"terminal ID:\n"
"    '^'?('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;"

#: ../../../documentation/301_grammarlanguage.md:747
msgid ""
"terminal INT returns ecore::EInt:\n"
"    ('0'..'9')+;"
msgstr ""
"terminal INT returns ecore::EInt:\n"
"    ('0'..'9')+;"

#: ../../../documentation/301_grammarlanguage.md:750
msgid ""
"terminal STRING:\n"
"    '\"' ( '\\\\'('b'|'t'|'n'|'f'|'r'|'u'|'\"'|\"'\"|'\\\\') | !('\\\\'|'\"') )* '\"' |\n"
"    \"'\" ( '\\\\'('b'|'t'|'n'|'f'|'r'|'u'|'\"'|\"'\"|'\\\\') | !('\\\\'|\"'\") )* \"'\";"
msgstr ""
"terminal STRING:\n"
"    '\"' ( '\\\\'('b'|'t'|'n'|'f'|'r'|'u'|'\"'|\"'\"|'\\\\') | !('\\\\'|'\"') )* '\"' |\n"
"    \"'\" ( '\\\\'('b'|'t'|'n'|'f'|'r'|'u'|'\"'|\"'\"|'\\\\') | !('\\\\'|\"'\") )* \"'\";"

#: ../../../documentation/301_grammarlanguage.md:754
msgid ""
"terminal ML_COMMENT:\n"
"    '/*' -> '*/';"
msgstr ""
"terminal ML_COMMENT:\n"
"    '/*' -> '*/';"

#: ../../../documentation/301_grammarlanguage.md:757
msgid ""
"terminal SL_COMMENT:\n"
"    '//' !('\n"
"'|'
')* ('
'? '\n"
"')?;"
msgstr ""
"terminal SL_COMMENT:\n"
"    '//' !('\n"
"'|'
')* ('
'? '\n"
"')?;"

#: ../../../documentation/301_grammarlanguage.md:760
msgid ""
"terminal WS:\n"
"    (' '|'\t'|'
'|'\n"
"')+;"
msgstr ""
"terminal WS:\n"
"    (' '|'\t'|'
'|'\n"
"')+;"

#: ../../../documentation/301_grammarlanguage.md:763
msgid ""
"terminal ANY_OTHER:\n"
"    .;\n"
"```"
msgstr ""
"terminal ANY_OTHER:\n"
"    .;\n"
"```"

#: ../../../documentation/301_grammarlanguage.md:769
msgid "**[Next Chapter: Configuration](302_configuration.html)**"
msgstr "**[次章: コンフィギュレーション](302_configuration.html)**"
